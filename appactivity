/* Copyright (c) 2011-2013 Panasonic Corporation */
package com.panasonic.smart.gemini;

import android.app.Activity;
import android.app.AppOpsManager;
import android.app.DownloadManager;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.PowerManager;
import android.text.InputFilter;
import android.text.InputType;
import android.text.Spanned;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.Window;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup.LayoutParams;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.webkit.ConsoleMessage;
import android.webkit.GeolocationPermissions;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;
import android.webkit.HttpAuthHandler;
import android.webkit.WebBackForwardList;
import android.webkit.WebChromeClient;
import android.webkit.WebHistoryItem;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.webkit.WebViewDatabase;

// SSLエラー暫定対応 add start
import android.webkit.SslErrorHandler;
import android.net.http.SslError;
import android.net.wifi.WifiManager;
// SSLエラー暫定対応 add end

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.WeakHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationManager;
import android.media.AudioManager;
import android.media.SoundPool;
import java.io.File;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;

import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.drawable.AnimationDrawable;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Matrix;
import android.net.Uri;
import android.preference.PreferenceManager;
import android.provider.ContactsContract;
import android.provider.MediaStore;
import android.util.Base64;
import android.util.TypedValue;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.ImageView.ScaleType;
import android.widget.TextView.BufferType;
import android.widget.Toast;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.URL;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

//import com.panasonic.smart.gemini.R;

/** Util.Log クラスの代わりに、Gemini用Logクラスを使用する。*/
//import android.util.Log;
import com.google.android.gcm.GCMRegistrar;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.ResultCallback;
import com.google.android.gms.common.api.Status;
import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
import com.google.android.gms.location.Geofence;
import com.google.android.gms.location.GeofencingRequest;
import com.google.android.gms.location.LocationServices;
import com.panasonic.smart.gemini.Log;
import com.panasonic.smart.gemini.common.ExternalServiceUtil;
import com.panasonic.smart.gemini.common.GeminiActivity;
import com.panasonic.smart.gemini.common.ShortcutsManager;
import com.panasonic.smart.gemini.common.SnsParams;
import com.panasonic.smart.gemini.common.SnsWrapper;
import com.panasonic.smart.gemini.common.SnsUtils;
import com.panasonic.smart.gemini.common.TabUtil;
import com.panasonic.smart.gemini.common.GoogleAnalyticsManager;
import com.panasonic.smart.gemini.HttpClientUtil;

//2012/09/12 #5017 アプリ同時起動対応 modified
//CHG-ST:TF-#16470 起動時お知らせ対応 2014/03/17 (PSNRD)
//public class StartApp extends Activity implements nfcWrapper.FelicaPollingResultListener {
public class StartApp extends GeminiActivity implements nfcWrapper.FelicaPollingResultListener {
//CHG-ED:TF-#16470 起動時お知らせ対応 2014/03/17 (PSNRD)
	/** Called when the activity is first created. */
	private static final int DISABLE_NFC = 0;				// タグ取得-無効
	private static final int ENABLE_NFC_RD = 1;				// タグ取得-有効（READのみ）
	private static final int ENABLE_NFC_RW = 2;				// タグ取得-有効（READ/WRITE）
	private static final int ENABLE_NFC_TIME = 3;			// タグ取得-有効（時刻設定）
	private static final int ENABLE_NFC_REPAIR = 4;			// タグ取得-有効（計測データ回復）
	private static final int ENABLE_NFC_USERID = 5;			// タグ取得-有効（ユーザ識別コード）
	private static final int ENABLE_NFC_PRELOGIN = 6;		// タグ取得-有効（ログイン前）
	private static final int ENABLE_NFC_GETUSERINFO = 7;	// タグ取得-有効（ユーザ情報取得）
	private static final int ENABLE_NFC_SETUSERINFO = 8;	// タグ取得-有効（ユーザ情報設定）
	private static final int ENABLE_NFC_DELUSERINFO = 9;	// タグ取得-有効（ユーザ情報削除）
	private static final int ENABLE_NFC_RDMEASURE = 10;		// タグ取得-有効（計測データ読出）
	private static final int ENABLE_NFC_REGISTER = 11;		// タグ取得-有効（My家電登録）
//ADD-ST 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応
	private static final int ENABLE_NFC_RDCSDATA = 12;		// タグ取得-有効（CSデータ読み出し）
//ADD-ED 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応

	private static final int ERR_ID_NFC_POLLING_TIMEOUT	= -11;  //ポーリングタイムアウト

	private static final int REQUEST_CAMERA = 1;			// Activityリクエストコード（カメラ）
	private static final int REQUEST_GALLERY = 2;			// Activityリクエストコード（ギャラリー）
	//private static final int REQUEST_MAIL = 3;			// Activityリクエストコード（メール）
// ADD-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	private static final int REQUEST_CONTACTS = 4;			// Activityリクエストコード（メール）
// ADD-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	private static final int VGA_WIDTH = 640;				// VGAサイズ横（ギャラリー用）
	private static final int VGA_HEIGHT = 480;				// VGAサイズ縦（ギャラリー用）

	private final byte[] USER_ID_CODE_DUMMY = new byte[] {
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		}; // ユーザ識別コード(16byte、上記はテストタグ用)

	public static final int CATEGORY_DUMMY 	            = 0; // ダミー
	public static final int CATEGORY_COMPOSITIONMETER 	= 1; // 体組成計
	public static final int CATEGORY_CALORIEMETER		= 2; // 活動量計
	public static final int CATEGORY_BLOODPRESSUREMETER	= 3; // 血圧計

	public static final int INFOSIZE_COMPOSITIONMETER	= 128; // ユーザ情報サイズ（体組成計）
	public static final int INFOSIZE_CALORIEMETER		= 32; // ユーザ情報サイズ（活動量計）
	public static final int INFOADDR_COMPOSITIONMETER1	= 0x6010; // ユーザ情報設定アドレス（体組成計1・活動量計）
	public static final int INFOADDR_COMPOSITIONMETER2	= 0x6030; // ユーザ情報設定アドレス（体組成計2）
	public static final int INFOADDR_COMPOSITIONMETER3	= 0x6050; // ユーザ情報設定アドレス（体組成計3）
	public static final int INFOADDR_COMPOSITIONMETER4	= 0x6070; // ユーザ情報設定アドレス（体組成計4）
																										//DEL@PROD
// ダイジェスト認証-入力ダイアログ非表示版（裏で認証） start											//DEL@PROD
	public static final String USERNAME = "gem1n1";														//DEL@PROD
	public static final String PASSWORD = "tempdev9";													//DEL@PROD
	public static final String REALM = "vrs";															//DEL@PROD

	//本番サーバホスト名 (本番/STG判別用)
	public static final String PROD_HOST = "smartlife.panasonic.jp";

	//Gemini本番環境
	public static final String AUTH_HOST = "smartlife.panasonic.jp";

	//public static final String AUTH_HOST = "prev.smartlife.panasonic.jp"; //プレビュー用				//DEL@PROD
	public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":443"; //ICSでの認証用@https
	public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":80"; //ICSでの認証用@http
	//Geminiステージング１環境																			//DEL@PROD
	//public static final String AUTH_HOST = "smartlife.stg.panasonic.co.jp";							//DEL@PROD
	//public static final String AUTH_HOST = "prev.smartlife.stg.panasonic.co.jp"; //プレビュー用		//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":80"; //ICSでの認証用@http				//DEL@PROD
	//Geminiステージング２環境																			//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":10443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":10080"; //ICSでの認証用@http			//DEL@PROD
	//Geminiステージング３環境																			//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":20443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":20080"; //ICSでの認証用@http			//DEL@PROD
	//Geminiステージング４環境																			//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":30443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":30080"; //ICSでの認証用@http			//DEL@PROD
	//Geminiステージング５環境																			//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":40443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":40080"; //ICSでの認証用@http			//DEL@PROD
	//Geminiステージング６環境																			//DEL@PROD
	//public static final String AUTH_HOST_PORT1 = AUTH_HOST + ":50443"; //ICSでの認証用@https			//DEL@PROD
	//public static final String AUTH_HOST_PORT2 = AUTH_HOST + ":50080"; //ICSでの認証用@http			//DEL@PROD
																										//DEL@PROD
	//GeminiSTGサーバホスト名 (SharedPreferences設定状態判別用)											//DEL@PROD
	public static final String STG_AUTH_HOST = "smartlife.stg.panasonic.co.jp";							//DEL@PROD
	public static final String STG1_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":443";							//DEL@PROD
	public static final String STG1_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":80";							//DEL@PROD
	public static final String STG2_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":10443";							//DEL@PROD
	public static final String STG2_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":10080";							//DEL@PROD
	public static final String STG3_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":20443";							//DEL@PROD
	public static final String STG3_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":20080";							//DEL@PROD
	public static final String STG4_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":30443";							//DEL@PROD
	public static final String STG4_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":30080";							//DEL@PROD
	public static final String STG5_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":40443";							//DEL@PROD
	public static final String STG5_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":40080";							//DEL@PROD
	public static final String STG6_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":50443";							//DEL@PROD
	public static final String STG6_AUTH_HOST_PORT2 = STG_AUTH_HOST + ":50080";							//DEL@PROD
	// ADD-ST [仕様変更作業管理 TF-#24017] MarsFlag移行：本線化対応											//DEL@PROD
	public static final String STG1_SOLR_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":12443";					//DEL@PROD
	public static final String STG5_SOLR_AUTH_HOST_PORT1 = STG_AUTH_HOST + ":52443";					//DEL@PROD
	// ADD-ED [仕様変更作業管理 TF-#24017] MarsFlag移行：本線化対応											//DEL@PROD
																										//DEL@PROD
	//Gemini-Prevサーバホスト名 (SharedPreferences設定状態判別用)										//DEL@PROD
	public static final String PREV_AUTH_HOST = "prev.smartlife.panasonic.jp";							//DEL@PROD
	public static final String PREV_AUTH_HOST_PORT1 = PREV_AUTH_HOST + ":443";							//DEL@PROD
	public static final String PREV_AUTH_HOST_PORT2 = PREV_AUTH_HOST + ":80";							//DEL@PROD
																										//DEL@PROD
	//Gemini-PrevSTGサーバホスト名 (SharedPreferences設定状態判別用)									//DEL@PROD
	public static final String PREV_STG_AUTH_HOST = "prev.smartlife.stg.panasonic.co.jp";				//DEL@PROD
	public static final String PREV_STG1_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":443";					//DEL@PROD
	public static final String PREV_STG1_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":80";					//DEL@PROD
	public static final String PREV_STG2_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":10443";				//DEL@PROD
	public static final String PREV_STG2_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":10080";				//DEL@PROD
	public static final String PREV_STG3_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":20443";				//DEL@PROD
	public static final String PREV_STG3_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":20080";				//DEL@PROD
	public static final String PREV_STG4_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":30443";				//DEL@PROD
	public static final String PREV_STG4_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":30080";				//DEL@PROD
	public static final String PREV_STG5_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":40443";				//DEL@PROD
	public static final String PREV_STG5_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":40080";				//DEL@PROD
	public static final String PREV_STG6_AUTH_HOST_PORT1 = PREV_STG_AUTH_HOST + ":50443";				//DEL@PROD
	public static final String PREV_STG6_AUTH_HOST_PORT2 = PREV_STG_AUTH_HOST + ":50080";				//DEL@PROD
// ダイジェスト認証-入力ダイアログ非表示版（裏で認証） end												//DEL@PROD
																										//DEL@PROD
// TF-#7707 クラパナSTG向けBASIC認証対応：STEP1 2013/01/28 add start									//DEL@PROD
	public static final String CP_USERNAME = "";														//DEL@PROD
	public static final String CP_PASSWORD = "";	// 2013/05/01-										//DEL@PROD
	public static final String CP_REALM = "Input ID and Password.";										//DEL@PROD
																										//DEL@PROD
	//クラパナステージング１環境																		//DEL@PROD
	public static final String CP1_AUTH_HOST = "spn-club.stg.panasonic.co.jp";							//DEL@PROD
	public static final String CP1_AUTH_HOST_PORT1 = CP1_AUTH_HOST + ":443";	//ICSでの認証用@https	//DEL@PROD
	public static final String CP1_AUTH_HOST_PORT2 = CP1_AUTH_HOST + ":80";		//ICSでの認証用@http	//DEL@PROD
	//クラパナステージング２環境																		//DEL@PROD
	public static final String CP2_AUTH_HOST = "spn-club.stg2.panasonic.co.jp";							//DEL@PROD
	public static final String CP2_AUTH_HOST_PORT1 = CP2_AUTH_HOST + ":443";	//ICSでの認証用@https	//DEL@PROD
	public static final String CP2_AUTH_HOST_PORT2 = CP2_AUTH_HOST + ":80";		//ICSでの認証用@http	//DEL@PROD
// TF-#7707 クラパナSTG向けBASIC認証対応：STEP1 2013/01/28 add end										//DEL@PROD

	//プレビュー環境フラグ
	private boolean isPreviewApp = false;

	// 2012/02/13 URLスキーム対応 add start
	public static final String GEMINI_LOGIN_URL = "https://" + AUTH_HOST + "/dynamic/html/portal/12a/gmssss001.html?goto=";	//本番,STG1
	//public static final String GEMINI_LOGIN_URL = "https://" + AUTH_HOST_PORT1 + "/dynamic/html/portal/12a/gmssss001.html?goto="; //STG2～6	//DEL@PROD
// ADD-ST [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
	public static final String GEMINI_SCURL_URL = "https://" + AUTH_HOST + "/dynamic/html/portal/12a/shortcut.html?goto=";	//本番,STG1
	//public static final String GEMINI_SCURL_URL = "https://" + AUTH_HOST_PORT1 + "/dynamic/html/portal/12a/shortcut.html?goto="; //STG2～6	//DEL@PROD
// ADD-ED [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
	// 2012/02/13 URLスキーム対応 add end

	public static final String ACTION_CLEAR_CACHE = "com.panasonic.smart.gemini.ClearCache";
	public static final String ACTION_NOTIFY_UPDATE	= "com.panasonic.smart.gemini.NotifyUpdate";

// ADD-START UX改善 PMCRD 2013-04-05
	//ローカル環境判別用
	public static final boolean USE_LOCAL_SERVER = (AUTH_HOST.contains("smartlife.") == false); // TODO: 最終的には削除
// ADD-END   UX改善 PMCRD 2013-04-05
// ADD-ST 作業管理 #24426:【PUSH通知残課題対応】Android4.1以降「設定＞アプリ」での通知ON/OFF設定状態を取得できない PSDCD徐 2015-12-02
	private static final String CHECK_OP_NO_THROW = "checkOpNoThrow";
	private static final String OP_POST_NOTIFICATION = "OP_POST_NOTIFICATION";
// ADD-ED 作業管理 #24426:【PUSH通知残課題対応】Android4.1以降「設定＞アプリ」での通知ON/OFF設定状態を取得できない PSDCD徐 2015-12-02
	// メニューキーによるアプリ終了(true:有効、false:無効)
	private boolean supportApplicationMenuFlg = false;

	private WebView wv;
	private nfcWrapper nfcW;
	private JsBridge jsB;
//MOD-ST PAD-#11726
	private VersionCheck verChk;
//MOD-EN PAD-#11726
	private int isEnableNfc = DISABLE_NFC;					// NFCタグ取得有効/無効
	// スプラッシュ画面用ImageView
	private ImageView splashImage = null;
	private static long splashStart = 0;
	private static long splashEnd = 0;
	private static final long SPLASH_TIME = 2000;           // スプラッシュ画面表示の規定時間（msec）

	private boolean isNfcExist = false;						// NFC搭載/未搭載
	private boolean isNfcAvailable = false;					// NFC設定ON/OFF

	private boolean isPoolingPaused = false;   // poolingPauseフラグ ※ FelicaとNFCで動作が異なるので、Felicaの場合のみ使用

	/* TF-#2579(PAD-#7666)で投入したNFCポーリングタイマー関係のフィールド */
    private Timer mNfcPollingTimer = null;					// NFC ポーリングタイマー
	private Handler mNfcPollingHandler = new Handler();	// NFC ポーリングタイマーハンドラ
	private Boolean isNfcPolling = false;	// NFC ポーリングタイマー起動フラグ
	private int lastTimeoutSec = 60;	// NFC 最終設定タイムアウト時間


	private SoundPool sp = null;
	private int soundId[] = {0,0};
	private float mLeftVol = 0.0F;
	private float mRightVol = 0.0F;
	private Uri mImageUri;

	private byte[] mUserIdCode;								// ユーザ識別コード
	private int  mDesignatedCategory = CATEGORY_DUMMY;      // カテゴリ

	// レスポンスタイムアウト検知用
    private static final int RESPONSE_TIMEOUT = 60000;
	private Timer mRespTimer = null;
	private Handler mRespHandler = new Handler();

	private BroadcastReceiver mReceiver = null;
	private BroadcastReceiver nwReceiver = null;
    // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-26
    private BroadcastReceiver dlReceiver = null;
    // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-26

	// タッチの状態
	private final int TOUCH_NO_CHECK = 99;
	private final int TOUCH_OK = 0;
	private final int TOUCH_NG = 1;
	private int mTouchStat = TOUCH_NO_CHECK;  // タッチの可否（99：未判定、0：可能、1：未搭載、左記以外：初期化エラー）
	private int mLastTouchResult = nfcWrapper.RES_SUCCESS;
	private Boolean mTouchRwTimeoutOccuredForNfc = false;
	// 2012/08/02 #4177対応 add start
	private boolean mCheckTouchStat = false;  // Felicaチェックが開始されたことを示す実行状態フラグ
	private int mTimeoutSec = 0;
	// 2012/08/02 #4177対応 add end

	// 読み込み中ダイアログ
	private static ProgressDialog mWaitDialog = null;
	private static List<String> mNoDialogList = null;

	// メニューを表示しない画面一覧
	private static List<String> mNoMenuList = null;

	// Cookie対応
	private CookieSyncManager cookieSyncManager = null;
	public CookieManager cookieManager = null;

    // 自動消灯のON/OFF対応
    private PowerManager pm = null;
    private PowerManager.WakeLock fullWakeLock = null;
	private boolean fullWakeLockFlg = false;
	private boolean onPauseFullWakeLockFlg = false;

	// バージョンチェック用
	private final int VERSION_CHECK_INTERVAL = 15 * 60 * 1000; // 15分
	private Intent mNotifyUpdatePendingIntent = null;
//DEL-ST PAD-#11726
//DEL-EN PAD-#11726
//ADD-ST PAD-#11726
	// バージョンファイルパス（本番、STGサーバ共通）
	public static final String VERSION_FILE = "/dynamic/html/version.txt";
	// アプリ起動時判定フラグ
	private boolean isAppStartUp = true;
//ADD-EN PAD-#11726

// ADD-ST [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある
    // onResume時のVERSION_FILEファイル取得判定フラグ
    private boolean requiredVersionFile = true;
// ADD-ED [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある
	private AlertDialog mVupNotifyDialog = null; // 二重起動防止用

	private boolean forseRedrawFlag = true;

	// システム(タップ効果)音量の制御
	//DEL-ST 欠陥管理#8722
	//private int tapSoundVolume = 0; //元の音量を記憶させておくための変数
	//private AudioManager myAudioManager = null;
	//DEL-ED 欠陥管理#8722

	static {
		// 読み込み中ダイアログを表示しない画面一覧
		mNoDialogList = new ArrayList<String>();
		mNoDialogList.add("begin");        // スプラッシュ画面
		mNoDialogList.add("gmssss001");    // スプラッシュ画面
		//mNoDialogList.add("bwmekb001");    // アプリメイン画面（血圧計）
		//mNoDialogList.add("fnmekb001");    // アプリメイン画面（体組成計・活動量計）

		// メニューを表示しない画面一覧
		// 対応時点ではスプラッシュと同じ画面だが、拡張性を考えて変数は分ける。
		mNoMenuList = new ArrayList<String>();
		mNoMenuList.add("begin");        // スプラッシュ画面
		mNoMenuList.add("gmssss001");    // スプラッシュ画面
	}

	// 入力ダイアログ表示フラグ（true:表示中、false:非表示）
	private boolean inputDialogFlg = false;
	// TF-#4508 入力ダイアログへの参照。Java側から意図的に閉じるために保持
	private AlertDialog inputDialog = null;


	// TF-#3784 アプリ終了確認P.U.重複表示 2012/07/16 張
	// アプリ終了確認P.U.ビルダー
	private AlertDialog finishAppDlg = null;
																										//DEL@PROD
	// Digest認証＆Basic認証－入力ダイアログ表示版														//DEL@PROD
	private AlertDialog mHttpAuthDialog = null;															//DEL@PROD

	/** エラー処理関連 **/
	// システムエラーコード
	private static final String SYSTEM_ERR_CODE_G_11292_30001 = "G-11292-30001";
	private static final String SYSTEM_ERR_CODE_G_11292_30002 = "G-11292-30002";
	private static final String SYSTEM_ERR_CODE_G_11292_30003 = "G-11292-30003";
	private static final String SYSTEM_ERR_CODE_G_11292_30004 = "G-11292-30004";
	private static final String SYSTEM_ERR_CODE_G_11292_30104 = "G-11292-30104";

	// エラーメッセージ
	private static final String ERR_MESSAGE_G_11292_30001 = "ネットワーク通信が必要です。<br/>通信が可能な場所で、<br/>もう一度やり直してください。";
	private static final String ERR_MESSAGE_G_11292_30002 = "サーバー接続に失敗しました。<br/>申し訳ございませんが、もう一度<br/>やり直してください。";
	private static final String ERR_MESSAGE_G_11292_30003 = "サーバー接続に失敗しました。<br/>申し訳ございませんが、もう一度<br/>やり直してください。";
	private static final String ERR_MESSAGE_G_11292_30004 = "ネットワーク通信が必要です。<br/>通信が可能な場所で、<br/>もう一度やり直してください。";
	private static final String ERR_MESSAGE_G_11292_30104 = "システムエラーが発生しました。<br/>ご迷惑をおかけし申し訳ございません。";

	// 復帰ボタン名称
	//private static final String BTN_NAME_RETURN = "戻る";
	private static final String BTN_NAME_RETRY = "リトライ";
	private static final String BTN_NAME_APPLICATION_FINISH = "アプリを終了する";

	// エラー情報
	private static final Map<String, Map<String, String>> ERROR_INFO = new WeakHashMap<String, Map<String, String>>() {
		{
			put(SYSTEM_ERR_CODE_G_11292_30001, new WeakHashMap<String, String>() {
				{
					put("ERR_MESSAGE", ERR_MESSAGE_G_11292_30001);
					put("BTN_NAME", BTN_NAME_RETRY);
				}
			});

			put(SYSTEM_ERR_CODE_G_11292_30002, new WeakHashMap<String, String>() {
				{
					put("ERR_MESSAGE", ERR_MESSAGE_G_11292_30002);
					put("BTN_NAME", BTN_NAME_RETRY);
				}
			});

			put(SYSTEM_ERR_CODE_G_11292_30003, new WeakHashMap<String, String>() {
				{
					put("ERR_MESSAGE", ERR_MESSAGE_G_11292_30003);
					put("BTN_NAME", BTN_NAME_RETRY);
				}
			});

			put(SYSTEM_ERR_CODE_G_11292_30004, new WeakHashMap<String, String>() {
				{
					put("ERR_MESSAGE", ERR_MESSAGE_G_11292_30004);
					put("BTN_NAME", BTN_NAME_RETRY);
				}
			});

			put(SYSTEM_ERR_CODE_G_11292_30104, new WeakHashMap<String, String>() {
				{
					put("ERR_MESSAGE", ERR_MESSAGE_G_11292_30104);
					put("BTN_NAME", BTN_NAME_APPLICATION_FINISH);
				}
			});
		}
	};

	// システムエラーコード
	private String systemErrCode = "";
	// エラーメッセージ
	private String errMessage = "";
	// 復帰ボタン名称
	private String btnName = "";
	// ユーザメモリに対する書込み開始アドレス（体組成計）
	private int mUserMemory = INFOADDR_COMPOSITIONMETER1;

	// エアコンPU表示ダイアログ
	private static Dialog pd = null;
	// エアコンPUのアイコン表示に使用
	private static AnimationDrawable anim = null;

	// Exception情報取得有効無効フラグ
	private static final boolean ENABLE_EXCEPTION_INFO_OUTPUT = true;
	public void showBugReportDialogIfNeeded() {
		if (ENABLE_EXCEPTION_INFO_OUTPUT) {
			if (!ExceptionInfoOutputHandler.showBugReportDialogIfNeeded(this)) {
				// UncaughtExecptionHandlerの設定
				Thread.setDefaultUncaughtExceptionHandler(new ExceptionInfoOutputHandler(this));
			}
		}
	}

	// アプリ状態保持用のクラス
	private ApplicationStateInfo asi = null;

	// リードライト処理スレッド化
	private Handler handler = new Handler();

	// TF-#2516 対応 洗濯機、予約設定ありタッチ画面用フラグ(2012/06/14 長坂)
	private String whTimerUseFlag = "false";

	// TF-#2917 対応 onPageStarted ～ onPageFinishedの間 true その他 false
	private boolean isPageLoading = false;

	// TF-#2917 対応 onPageStarted ～ onPageFinishedの間で既にエラーが発生している場合はtrue
	private boolean isJsError = false;


	// TF-#1915 検証NG対応(ProgressDialogの処理) (2012/07/02 原)
	private boolean progressDialogFlag = true;

	// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
	private boolean pageTransactionFlag = false;

	// SNS連携用
	private SnsWrapper mSns;

	// ADD-START UX改善 PMCRD 2013-03-18
	private ShortcutsManager mScManager;
	private TabUtil mTabUtil;
	public TabUtil getTabUtil() { return mTabUtil; }
	// ADD-END   UX改善 PMCRD 2013-03-18
// ADD-ST 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
	// Google APIKEY
	public static final String ApiKey = "AIzaSyBfvRHDRBrY0PDiPn7ADfdM8mZZvSM1Kv4";
	// Google API Project ID
// CHG-ST #25083:【PUSH通知】GCM用プロダクトキーの変更 PSDCD肖 2016-01-20
	public static final String SENDER_ID = "750891385421";
// CHG-ED #25083:【PUSH通知】GCM用プロダクトキーの変更 PSDCD肖 2016-01-20
// ADD-ST #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
	public static final String SENDER_ID_PROD = "577453067493";
// ADD-ED #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
	public static final String ACTION_PUSH_MESSAGE_GCM = "action_push_message_gcm";
	public static final String PUSH_REGISTER_KEY = "push_register_key";
// ADD-ST #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
	public static final String THRESHOLD_KEY = "threshold_key";
// ADD-ED #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
	public static final String PUSH_RECEIVE_TOKEN = "push_receive_token";
	public static final String PUSH_RECEIVE_APPLIANCE_ID = "push_receive_appliance_id";
	public static final String PUSH_RECEIVE_MESSAGE = "push_receive_message";
	public static final String PUSH_RECEIVE_SERVICE_ID = "push_receive_service_id";
//CHG-ST #26008:【PUSH通知】STG5向けリリース用ソース修正 PSDCD肖 2016-03-16
	public static final String GEMINI_PUSH_URL = GEMINI_LOGIN_URL;
//CHG-ED #26008:【PUSH通知】STG5向けリリース用ソース修正 PSDCD肖 2016-03-16
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-19
	public boolean showPushBtnInMenu = Util.USE_DEBUG_LOG;
// ADD-ST #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
	public boolean showThresholdSetBtnInMenu = Util.USE_DEBUG_LOG;
// ADD-ED #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
// ADD-ST #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
	public boolean showPositionInfoInMenu = Util.USE_DEBUG_LOG;
// ADD-ED #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-19
// ADD-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
// DEL-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
// DEL-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
// ADD-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
	public static final boolean CONVENTION_DEMO_FLAG = false;
// ADD-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17	
    /**
     * Provides the entry point to Google Play services.
     */
    protected static GoogleApiClient mGoogleApiClient;

    /**
     * The list of geofences used in this sample.
     */
    protected static ArrayList<Geofence> mGeofenceList;

    /**
     * Used when requesting to add or remove geofences.
     */
    private static PendingIntent mGeofencePendingIntent;
	private static Context gContext;
// ADD-ED #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
// ADD-ED 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
// ADD-ST #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
	public static String senderId = SENDER_ID;
    static {
        if(AUTH_HOST.equals(PROD_HOST)) {
        	senderId = SENDER_ID_PROD;
        }
    }
// ADD-ED #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
	// 動作モードLIST
	private static final Map<String, ArrayList<String>> MODE_FLAG_LIST = new WeakHashMap<String, ArrayList<String>>() {
		{
			/*
			 * <リスト構成>
			 * 　　動作フラグ名=[フラグ設定値, デバッグ情報の表示名, デバッグ情報の表示要否]
			 *
			 * <設定例>
			 * 　　THIRD_PARTY_SUPPORT=[true, 3rd party連携, true]
			 */

			// 快眠アプリ
			put("PANA_SLEEP_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("快眠アプリ");
					add("false");
				}
			});
			
			// 3rd party連携
			put("THIRD_PARTY_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("3rd party連携");
					add("false");
				}
			});
			// AVC連携
			put("AVC_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("AVC連携");
					add("false");
				}
			});
			// AVC連携(UPNP_LIBRARY_LOAD_CHECK)
			put("UPNP_LIBRARY_LOAD_CHECK_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("AVC連携(UPNP_LIBRARY_LOAD)");
					add("false");
				}
			});
			// AVC連携(取説DL)
			put("FILE_DL_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("AVC連携(取説DL)");
					add("false");
				}
			});
			// 音声認識
			put("SR_SUPPORT_12AC", new ArrayList<String>() {
				{
					add("true");
					add("音声認識");
					add("true");
				}
			});
			// UX改善
			put("SC_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("UX革新");
					add("false");
				}
			});
			// UX改善(エアコンカスタム)
			put("SC_12AC_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("UX革新(エアコンカスタム)");
					add("true");
				}
			});
			// UX革新(お客様意見収集)
			put("FEEDBACK_SUPPORT", new ArrayList<String>() {
				{
					add("false");
					add("UX革新(お客様意見収集)");
					add("false");
				}
			});
// DEL-ST [仕様変更作業管理 TF-#11100] 【UI改善】カスタムショートカット予約時刻変更(#9779)の蓋開け：Javaの修正
// ADD-ST [仕様変更作業管理 TF-#10406] 【UI改善】カスタムショートカット予約時刻変更(#9779)の蓋閉じ
//			// UX改善(カスタムショートカット予約時刻変更)
//			put("SC_TIMER_SETTING_SUPPORT", new ArrayList<String>() {
//				{
//					add("true");
//					add("UX革新(カスタムショートカット予約時刻変更)");
//					add("true");
//				}
//			});
// ADD-ED [仕様変更作業管理 TF-#10406] 【UI改善】カスタムショートカット予約時刻変更(#9779)の蓋閉じ
// DEL-ED [仕様変更作業管理 TF-#11100] 【UI改善】カスタムショートカット予約時刻変更(#9779)の蓋開け：Javaの修正
			// SNS連携(ライブラリ読込結果)
			put("SNS_LIBRARY_LOAD", new ArrayList<String>() {
				{
					add("false");
					add("SNS連携(ライブラリ読込結果)");
					add("true");
				}
			});
			// 音声認識(ライブラリ読込結果)
			put("VOICE_LIBRARY_LOAD", new ArrayList<String>() {
				{
					add("false");
					add("音声認識(ライブラリ読込結果)");
					add("true");
				}
			});
//ADD-ST PAD-#11726
			// 新バージョンチェック
			put("VERSION_CHECK_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("新バージョンチェック");
					add("false");
				}
			});
//ADD-EN PAD-#11726
//ADD-ST TF-#12152
			// 新バージョンチェック2
			put("VERSION_CHECK2_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("新バージョンチェック2");
					add("false");
				}
			});
//ADD-EN TF-#12152
// ADD-ST [仕様変更管理 TF-#11057] 【3rd Party連携】Weather News連携：携帯アプリHTML/JS対応
			put("WEATHER_NEWS_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("WeatherNews連携");
					add("true");
				}
			});
// ADD-ED [仕様変更管理 TF-#11057] 【3rd Party連携】Weather News連携：携帯アプリHTML/JS対応
// ADD-ST [仕様変更作業管理 TF-#11818] AVCショートカットの仕様変更：携帯アプリHTML/JS対応
			put("AVC_SHORTCUT2_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("AVCデフォルトショートカット(メニューを除く)");
					add("true");
				}
			});
// ADD-ED [仕様変更作業管理 TF-#11818] AVCショートカットの仕様変更：携帯アプリHTML/JS対応
// ADD-ST 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
			put("PUSH_MESSAGE_SUPPORT", new ArrayList<String>() {
				{
					add("true");
					add("PUSH通知");
					add("true");
				}
			});
// ADD-ED 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
		}
	};

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
    	// ログ出力用クラスの初期化
        Log.init(this);

        super.onCreate(savedInstanceState);
		Log.d("MyApplication", "onCreate()");
//ADD-START AVC連携　PSDCD肖　2012-11-26
		//ExternalAppManagerのsetContext()をコールして、アプリのコンテキストを設定
		ExternalAppManager.setContext(this);
//ADD-END AVC連携　PSDCD肖　2012-11-26

        // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-19
        FileDownloadManager.setContext(this);
        // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-19

        // Exception情報表示
        showBugReportDialogIfNeeded();

        // アプリ状態を更新
        asi = new ApplicationStateInfo(this);
        asi.saveState(ApplicationStateInfo.STATE_ONCREATE);

        // ログ出力機能
	    // LogWebView or WebViewの生成
		if(Util.USE_DEBUG_LOG){
			wv = new LogWebView(this);
			// Log.d("PAD","instantiated LogWebView");
		}else{
			wv = new GWebView(this);
			// Log.d("PAD","instantiated WebView");
		}

		// DEL-START UX改善 PMCRD 2013-03-18
		//FrameLayout layout = new FrameLayout(this);
		//layout.addView(wv);
		// DEL-END   UX改善 PMCRD 2013-03-18

		// ADD-START UX改善 PMCRD 2013-03-18
		// 【UX改善】タブとページのレイアウト設定
		mScManager = new ShortcutsManager(this);
		mTabUtil = new TabUtil(this, wv);
		RelativeLayout layout = mTabUtil.getTabPageLayout();
		// ADD-END   UX改善 PMCRD 2013-03-18

        // パワーマネージャ
        pm = (PowerManager) getSystemService(Context.POWER_SERVICE);

    	// Cookie処理の初期化
    	CookieSyncManager.createInstance(this);					//CookieSyncManagerのインスタンス生成
    	cookieSyncManager = CookieSyncManager.getInstance();	//CookieSyncManagerのインスタンス取得
    	cookieManager = CookieManager.getInstance();			//CookieManagerのインスタンス取得
    	cookieSyncManager.startSync();							//Cookieの同期(RAM⇔ストレージ)開始
    	Log.d("MyApplication", "cookieSyncManager.startSync");
        cookieManager.setAcceptCookie(true);					//Cookieを受け付ける設定をON
        cookieManager.removeExpiredCookie();					//期限切れのcookieを削除
        cookieSyncManager.sync();								//Cookieを同期
        Log.d("MyApplication", "cookie("+AUTH_HOST+"): "+cookieManager.getCookie("https://"+AUTH_HOST));

        // NFC機能が利用可能であるか判定する
    	// ※NFCラッパークラスを生成する前に判定する必要あり
    	// ※Felica機能の判定はactivateするまで分からない
    	// NFC搭載/未搭載の判定
    	isNfcExist = Util.checkNfcPackage(this.getApplicationContext());
		if (isNfcExist) {
	    	// NFC設定ON/OFFの判定
			isNfcAvailable = Util.checkNfcAvailable(this.getApplicationContext());
		}

        // NFCラッパー初期化
        nfcW = new nfcWrapper(this, wv, isNfcExist);
        nfcW.setNfcWrapper(nfcW);
        nfcWrapper.setFelicaPollingResultListener(this);	// 2012/09/12 #5017 アプリ同時起動対応 add

		// FeliCa Pollingの結果通知受信処理
		mReceiver = new BroadcastReceiver() {
			@Override
			public void onReceive(Context context, Intent intent) {
				Log.d("MyApplication","StartApp#BroadcastReceiver#onReceive");
				if (intent.getAction().equals(ACTION_CLEAR_CACHE)) {
					// キャッシュ削除
			    	Log.d("MyApplication", "StartApp#BroadcastReceiver#onReceive : Clear cache");
					wv.clearCache(true);
				}
				// DEL-ST:TF-#7100(脆弱性対策) 2012/12/21 ohtani
				//else if (intent.getAction().equals(ACTION_NOTIFY_UPDATE)) {
				//	// アプリ／コンテンツの更新を検出
				//	if (mWaitDialog != null && mWaitDialog.isShowing()) {
				//		// WebViewロード中：ロード完了後に表示するためにIntentを保存
				//		Log.d("MyApplication", "Postpone showing dialog, as loading is proceeding.");
				//		mNotifyUpdatePendingIntent = new Intent(intent);
				//	} else {
				//		// WebView非ロード中：ダイアログを即時表示
				//		Log.d("MyApplication", "Show dialog for notifying update.");
				//
				//		// キャッシュクリア
				//		// #7591 アプリトップのWebAPIキャッシュ化対応 (2012/07/10 NID小林)
				//		jsB.clearApiCache(wv.getUrl());
				//		wv.clearCache(true);
				//
				//		// FeliCa／NFCは停止
				//		disableNfc();
				//
				//		// ダイアログ表示(二重起動はしない)
				//		if (mVupNotifyDialog == null || !mVupNotifyDialog.isShowing()) {
				//			final boolean forAppUpdate = intent.getBooleanExtra("forAppUpdate", false);
				//			final String url = intent.getStringExtra("url");
				//
				//		    // ダイアログ表示
				//			AlertDialog.Builder builder = new AlertDialog.Builder(context);
				//			builder.setCancelable(false); // BACKキー無効
				//			builder.setOnKeyListener(new DialogInterface.OnKeyListener() {
				//				@Override
				//				public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				//					// Disable Search key
				//					if (keyCode == KeyEvent.KEYCODE_SEARCH) {
				//						return true;
				//					}
				//					return false;
				//				}
				//			});
				//			builder.setIcon(android.R.drawable.ic_dialog_info);
				//			builder.setTitle(intent.getStringExtra("title"));
				//			builder.setMessage(intent.getStringExtra("message"));
				//			builder.setPositiveButton(intent.getStringExtra("button"), new DialogInterface.OnClickListener() {
				//				public void onClick(DialogInterface di, int whichButton) {
				//					if (forAppUpdate) {
				//						// 指定アプリ(Google Play等)を起動
				//						Uri uri = Uri.parse(url);
				//						Log.d("MyApplication", "Launch uri=" + uri);
				//						Intent it = new Intent(Intent.ACTION_VIEW, uri);
				//						startActivity(it);
				//
				//						// アプリ終了
				//						finish();
				//					} else {
				//						// 指定URLへ遷移
				//	    				wv.loadUrl(url);
				//						// リロードの場合読み込み中ダイアログが表示されないのでここで表示
				//						// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
				//	    				openProgressDialogInner();
				//
				//						// レスポンスがない場合、タイムアウトする対応
				//						if (mRespTimer == null) {
				//							mRespTimer = new Timer(true);
				//							mRespTimer.schedule( new TimerTask() {
				//								@Override
				//								public void run() {
				//									mRespHandler.post( new Runnable() {
				//										public void run() {
				//											// タイムアウト処理
				//											closeProgressDialog();
				//											loadErrUrl(
				//												SYSTEM_ERR_CODE_G_11292_30002,
				//												ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("ERR_MESSAGE"),
				//												ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("BTN_NAME")
				//											);
				//										}
				//									});
				//								}
				//							}, RESPONSE_TIMEOUT);
				//						}
				//					}
				//				}
				//			});
				//			mVupNotifyDialog = builder.create();
				//
				//			// 2012/09/03 #5011対応 add start
				//	    	mVupNotifyDialog.setOnShowListener(new DialogInterface.OnShowListener(){
				//				@Override
				//				public void onShow(DialogInterface dialog) {
				//					Button btnPositive = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_POSITIVE);
				//					if (btnPositive != null) {
				//						final int WC = LinearLayout.LayoutParams.WRAP_CONTENT;
				//						final int FP = LinearLayout.LayoutParams.WRAP_CONTENT;
				//						final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WC, FP, 1);
				//						btnPositive.setLayoutParams(layoutParams);
				//						btnPositive.setSingleLine();
				//					}
				//				}
				//			});
				//			// 2012/09/03 #5011対応 add end
				//
				//			mVupNotifyDialog.show();
				//		} else {
				//			Log.d("MyApplication", "VUP dialog is already shown!");
				//		}
				//	}
				//
				//}
				// DEL-ED:TF-#7100(脆弱性対策) 2012/12/21 ohtani

				// 2012/09/12 #5017 アプリ同時起動対応 delete start
				//if (!intent.getAction().equals(nfcWrapper.ACTION_FELICA_POLLING_RESULT)) {
			    //	Log.d("MyApplication", "StartApp#BroadcastReceiver#onReceive : intent.getAction().equals(nfcWrapper.ACTION_FELICA_POLLING_RESULT) == false");
				//	return;
				//}
				//
				// FeliCa Polling結果通知受信
				//final int resultCode = intent.getIntExtra(
				//		nfcWrapper.KEY_FELICA_POLLING_RESULT,
				//		nfcWrapper.RES_SUCCESS);
				//
				//if (resultCode == nfcWrapper.RES_SUCCESS) {
				//	Log.d("MyApplication","StartApp#BroadcastReceiver#onReceive : Polling Success");
				//	// タグ取得完了を通知する
			    //	jsB.notifyNfcReady();   // とりあえず
				//
				//	// リードライト処理スレッド化
			    //	startReadWriteNfcThread();
				//
				//} else {
				//	switch (resultCode) {
				//	case nfcWrapper.RES_SUCCESS_NFC_AVAILABLE:
				//	case nfcWrapper.RES_SUCCESS_FELICA_AVAILABLE:
				//		Log.d("PAD","--- NFC or Felica resultCode =" + resultCode);
				//		mTouchStat = TOUCH_OK;
				//    	// 2012/08/02 #4177対応 add start
				//		if (mCheckTouchStat) {
				//			mCheckTouchStat = false;
				//			// タイムアウト設定
				//			nfcW.setPollingTimeout(mTimeoutSec);
				//			// isPoolingPauseがtrueの場合は、初期化のみ行い、nfcW.enableNfcは呼び出さない。
				//			if (!isPoolingPaused) {
				//				// Felica接続処理
				//				touchFromCheckTouchStat();
				//			} else {
				//				Log.d("MyApplication", "StartApp#BroadcastReceiver#onReceive : main Activity is pausing.");
				//			}
				//		}
				//    	// 2012/08/02 #4177対応 add end
				//		break;
				//	case nfcWrapper.RES_ERROR_NFC_DISABLED:		// 2012/08/21 #4487対応 add
				//		Log.d("PAD","--- NFC Disable resultCode =" + resultCode);
				//		mTouchStat = resultCode;
				//		if (isEnableNfc != DISABLE_NFC) {
				//			onErrorPolling(resultCode);
				//		}
				//		break;
				//	case nfcWrapper.RES_ERROR_NFC_NOT_EQUIPPED:
				//		Log.d("PAD","--- NFC Felica not Equipped resultCode =" + resultCode);
				//		mTouchStat = TOUCH_NG;
				//		break;
				//	case nfcWrapper.RES_ERROR_FELICA_NOT_INITIALIZED:
				//	case nfcWrapper.RES_ERROR_FELICA_OPEN_FAILED:
				//	case nfcWrapper.RES_ERROR_FELICA_LOCKED:
				//		Log.d("PAD","--- Felica init Error  resultCode =" + resultCode);
				//		mTouchStat = resultCode;
				//		if (isEnableNfc != DISABLE_NFC) {
				//			onErrorPolling(resultCode);
				//		}
				//		break;
				//    default:
				//		// Polling失敗時の処理を記載
				//		Log.d("PAD","--- Polling faild!  resultCode =" + resultCode);
				//		onErrorPolling(resultCode);
				//	}
				//}
				// 2012/09/12 #5017 アプリ同時起動対応 delete end
			}
		};
		IntentFilter filter = new IntentFilter();
		//filter.addAction(nfcWrapper.ACTION_FELICA_POLLING_RESULT);	// 2012/09/12 #5017 アプリ同時起動対応 delete
		filter.addAction(ACTION_CLEAR_CACHE);
		// DEL-ST:TF-#7100(脆弱性対策) 2012/12/21 ohtani
		//filter.addAction(ACTION_NOTIFY_UPDATE);
		// DEL-ED:TF-#7100(脆弱性対策) 2012/12/21 ohtani
		registerReceiver(mReceiver, filter);

// TF-#10033 Androidアプリアップデート後、起動できない件対応：2013/06/13 add start
		// 共有ライブラリのロードチェック
		try {
			// SNS連携で使用する共有ライブラリのロードチェック
			System.load("/data/data/com.panasonic.smart.gemini/lib/libgeminicr.so");
			setParam("SNS_LIBRARY_LOAD", "true");
		} catch (UnsatisfiedLinkError e) {
			e.printStackTrace();

			setParam("SNS_LIBRARY_LOAD", "false");
		}

		if (getParam("SR_SUPPORT_12AC").equals("true")) {
			// 「音声認識動作フラグON」の場合のみ音声認識ライブラリロードチェックを行なう
			try {
				// 音声認識で使用する共有ライブラリのロードチェック
				System.load("/data/data/com.panasonic.smart.gemini/lib/libFSR.so");
				setParam("VOICE_LIBRARY_LOAD", "true");
			} catch (UnsatisfiedLinkError e) {
				e.printStackTrace();

				setParam("VOICE_LIBRARY_LOAD", "false");
			}
		}
// TF-#10033 Androidアプリアップデート後、起動できない件対応：2013/06/13 add end
// ADD-START TF-#11088 Google Analyticsを利用したエラートラッキング対応
		// GoogleAnalytics設定		
		// エラートラッキング用の処理のため、暗号化ライブラリチェック後の可能な限り直ぐに実施
		if (getParam("SNS_LIBRARY_LOAD").equals("true")) {
			GoogleAnalyticsManager.initialize(this);
		}
//ADD-END   TF-#11088 Google Analyticsを利用したエラートラッキング対応

		// JSブリッジ初期化
    	jsB = new JsBridge(this, wv);
    	jsB.setJsBridge(jsB);

//MOD-ST PAD-#11726
		// VersionCheckクラス生成・初期化
		verChk = new VersionCheck(this, wv);
		verChk.setVersionCheck(verChk);
//MOD-EN PAD-#11726

    	// ADD TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
    	initApServerConf(); //DEL@PROD
// ADD-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李
    	initAp2ServerConf();//DEL@PROD
// ADD-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李
    	// キャッシュなど削除
        //wv.clearCache(true);
        //wv.clearFormData();
    	//wv.clearHistory();

        // JavaScript console 出力
        wv.setWebChromeClient(new WebChromeClient() {
            public boolean onConsoleMessage(ConsoleMessage cm) {
                Log.d("JavaScript", cm.message() + " -- From line "
                    + cm.lineNumber() + " of "
                    + cm.sourceId() );
                return true;
            }
// ADD-ST 作業管理 #23164:【PUSH通知＠海外連携】エアコン消し忘れ防止実装 PSDCD李
            // ある端末で地図が表示されない対応
			public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
            	Log.d("JavaScript", "origin=" + origin);
            	callback.invoke(origin, true, false);
            }
// ADD-ED 作業管理 #23164:【PUSH通知＠海外連携】エアコン消し忘れ防止実装 PSDCD李
        });

        // WebViewで横の隙間を消す方法(スクロールバー領域を消す)
        wv.setVerticalScrollbarOverlay(true);
        // wv.setScrollBarStyle(View.SCROLLBARS_INSIDE_OVERLAY);

// DEL-ST [2013A-WH] TF-#9111 2013年度商品対応 ohtani(PAD) 2013-04-15
// // ADD-ST [2013A-WH] TF-#6615 2013年度商品対応 Hamaguchi(PAD) 2013-02-25
//       // PluginState ON (使い方ガイドの動画再生対応)
//        wv.getSettings().setPluginState(WebSettings.PluginState.ON);
//        Log.d("MyApplication", "WebSettings.PluginState.ON");
//
//        //Android 3.0 (Level 11)以降なら H/WアクセラレートON
//        //(Android 2.3.3 （Level 10) では未定義のフラグ)
//        if (android.os.Build.VERSION.SDK_INT   > 10){
//            getWindow().setFlags(
// //              WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
// //             ,WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
//                0x01000000
//               ,0x01000000
//            );
//            Log.d("MyApplication", "WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED");
//        }
// // ADD-ED [2013A-WH] TF-#6615 2013年度商品対応 Hamaguchi(PAD) 2013-02-25
// DEL-ED [2013A-WH] TF-#9111 2013年度商品対応 ohtani(PAD) 2013-04-15

// ADD-ST [欠陥管理 TF-#20831] 【機種依存】端末設定のフォントサイズを「極大」にすると画面表示が崩れる場合がある
        // fontsize / zoom 設定のログ出し
        Log.d("MyApplication", "WebSettings.DefaultFixedFontSize =" + wv.getSettings().getDefaultFixedFontSize());
        Log.d("MyApplication", "WebSettings.DefaultFontSize =" + wv.getSettings().getDefaultFontSize());
        Log.d("MyApplication", "WebSettings.DefaultZoom =" + wv.getSettings().getDefaultZoom());
        // Nexus シリーズで、端末設定のフォントサイズに連動してしまう TextZoom を、標準サイズ＝100(%)に固定化する。
        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH){ // TextZoomはICSで追加
        	Log.d("MyApplication", "WebSetings.TextZoom = " + wv.getSettings().getTextZoom());
        	if (wv.getSettings().getTextZoom() != 100) {
        		Log.d("MyApplication", ">>> WebSetings.TextZoom set to 100");
        		wv.getSettings().setTextZoom(100);
        	}
        } else {
        	Log.d("MyApplication", "WebSetings.TextZoom = undefined (before ICS)");
        }
// ADD-ED [欠陥管理 TF-#20831] 【機種依存】端末設定のフォントサイズを「極大」にすると画面表示が崩れる場合がある

        // JavaScript 有効化
    	wv.getSettings().setJavaScriptEnabled(true);

        // localStorage 有効化
    	wv.getSettings().setDatabaseEnabled(true);
    	wv.getSettings().setDatabasePath("/data/data/" + getPackageName() + "/databases/");
    	wv.getSettings().setDomStorageEnabled(true);

    	// JsBridgeをJAVAスクリプトに設定
    	wv.addJavascriptInterface(jsB, "bridge");

    	// NFC あるいは Felicaが利用可能かチェック
    	nfcWrapper.checkNfcOrFelicaAvailability(this);
																										//DEL@PROD
//ダイジェスト認証-入力ダイアログ非表示（裏で認証）版 start												//DEL@PROD
        // WebViewのキャッシュ設定																		//DEL@PROD
        wv.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);								//DEL@PROD
        wv.getSettings().setJavaScriptEnabled(true);													//DEL@PROD
        WebViewDatabase.getInstance(this).clearHttpAuthUsernamePassword();								//DEL@PROD
        //ICSでは「host」ではなく「host:port」の形式で指定する必要がある(らしい)						//DEL@PROD
        Log.d("MyApplication", "CHECK: Build.VERSION.SDK_INT = "+ Build.VERSION.SDK_INT);				//DEL@PROD
        Log.d("MyApplication", "AUTH_HOST = "+ AUTH_HOST);												//DEL@PROD
        Log.d("MyApplication", "AUTH_HOST_PORT1 = "+ AUTH_HOST_PORT1);									//DEL@PROD
        Log.d("MyApplication", "AUTH_HOST_PORT2 = "+ AUTH_HOST_PORT2);									//DEL@PROD
        // ダイジェスト認証のホスト,ID,PASS設定 (本番サーバ以外:TF-#2274,#2296対応)						//DEL@PROD
        if (AUTH_HOST.equals(PROD_HOST) == false) {														//DEL@PROD
			// GeminiSTG、クラパナSTG向けの認証情報（SharedPreferences）の設定状態を判定する			//DEL@PROD
			if (!checkHttpAuthTbl()) {																	//DEL@PROD
				// 認証情報（SharedPreferences）へ初期値を設定する										//DEL@PROD
				InitHttpAuthTbl();																		//DEL@PROD
			}																							//DEL@PROD
			// 認証情報（SharedPreferences）を取得し、認証情報（setHttpAuthUsernamePassword）へ反映する	//DEL@PROD
			setHttpAuthTbl();																			//DEL@PROD
        }																								//DEL@PROD
//delegate_add_comment_point_not_deleted																//DEL@PROD
//ダイジェスト認証-入力ダイアログ非表示（裏で認証）版 end												//DEL@PROD

        // UserAgentの設定
        String uaString = null;
        String versionName = null;
        try {
			PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_META_DATA);
			versionName = packageInfo.versionName;
		} catch (NameNotFoundException e1) {
			Log.d("MyApplication", "cannot get package info.");
			e1.printStackTrace();
			versionName = "undefined";
		}
        if (AUTH_HOST.equals("smartlife.panasonic.jp")) {
        	uaString = wv.getSettings().getUserAgentString() + " PSS/" + versionName;
        } else if (AUTH_HOST.startsWith("prev.")){
        	uaString = wv.getSettings().getUserAgentString() + " PSS_PREV/" + versionName;
        } else {
        	uaString = wv.getSettings().getUserAgentString() + " PSS_STG/" + versionName;
        }
        //デバッグモードにより、ログ出力有無フラグを設定する(TF-#10601)
        if(Log.IS_DEBUGGABLE) {
        	uaString += " DEBUG_LOG";
        }
        Log.d("MyApplication", "UserAgent=\"" + uaString + "\"");
        ExternalServiceUtil.setDefaultUserAgentString(wv.getSettings().getUserAgentString());
        ExternalServiceUtil.setCustomUserAgentString(uaString);
        wv.getSettings().setUserAgentString(uaString);
//MOD-ST PAD-#11726
        // UserAgentの設定
        HttpClientUtil.setCustomUserAgentString(uaString);
        // PssTokenの設定
        String pssTokenString = Util.getPSSTokenString(this);
        HttpClientUtil.setPssTokenString(pssTokenString);
//MOD-EN PAD-#11726

// SSLエラー暫定対応 add start
        // ページナビゲーションのハンドリング
        wv.setWebViewClient(new WebViewClient() {
        	@Override
        	public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
        		Log.i("MyApplication", "onReceivedSslError()");
        		if (Util.IGNORE_SSL_ERROR) {
        			// SSL証明書エラーを無視する
        			handler.proceed();
        		} else {
        			// サーバとの通信に失敗しましたエラーを出す。
           			loadErrUrl(
        					SYSTEM_ERR_CODE_G_11292_30003,
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30003).get("ERR_MESSAGE"),
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30003).get("BTN_NAME")
        			);
        		}
        	}
        	@Override
        	public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
        		Log.i("MyApplication", "onReceivedError() " +
        				"errorCode=" + errorCode + " description=" + description + " failingUrl=" + failingUrl);

    			// "pss"から始まる場合、リトライ画面には遷移させない。
        		if (failingUrl.startsWith("pss")) {
        			return;
        		}

        		if(mWaitDialog != null){
        			mWaitDialog.dismiss();
        			mWaitDialog = null;
        		}
        		//画面を消去
        		closeSplashImage();
        		view.stopLoading();
        		view.clearView();

	    			// コンテンツ取得要求で失敗した場合、（ローカルファイルの）エラー画面を表示する
//    		    	String url = "file:///android_asset/www/err/12a/err_11.html";
//        		    if (Util.checkNetworkState(view.getContext()) == 0){
//        		    	url = "file:///android_asset/www/err/12a/err_10.html";
//        		    }
//	    	    	Log.d("MyApplication", "onReceivedError() loadUrl:" + url);
//	    	    	wv.loadUrl(url);

        		if (Util.checkNetworkState(view.getContext()) == 0) {
        			loadErrUrl(
        					SYSTEM_ERR_CODE_G_11292_30001,
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("ERR_MESSAGE"),
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("BTN_NAME")
        			);
        		} else {
        			loadErrUrl(
        					SYSTEM_ERR_CODE_G_11292_30002,
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("ERR_MESSAGE"),
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("BTN_NAME")
        			);
        		}
        	}
// ダイジェスト認証-入力ダイアログ非表示版（裏で認証） start											//DEL@PROD
        	@Override																					//DEL@PROD
        	public void onReceivedHttpAuthRequest(WebView view,											//DEL@PROD
        			final HttpAuthHandler handler, final String host, final String realm) {				//DEL@PROD
        		Log.i("MyApplication", "onReceivedHttpAuthRequest()");									//DEL@PROD
																										//DEL@PROD
// Digest認証＆Basic認証－入力ダイアログ表示版 start													//DEL@PROD
				String userName = null;																	//DEL@PROD
				String userPass = null;																	//DEL@PROD
				Log.d("MyApplication", "handler.useHttpAuthUsernamePassword() = " + handler.useHttpAuthUsernamePassword());	//DEL@PROD
				Log.d("MyApplication", "view = " + view);												//DEL@PROD
				if (handler.useHttpAuthUsernamePassword() && view != null) {							//DEL@PROD
        		String[] up = view.getHttpAuthUsernamePassword(host, realm);							//DEL@PROD
					Log.d("MyApplication", "up = " + up);												//DEL@PROD
        		if( up != null && up.length == 2 ) {													//DEL@PROD
						userName = up[0];																//DEL@PROD
						userPass = up[1];																//DEL@PROD
						Log.d("MyApplication", "up.length = " + up.length);								//DEL@PROD
						Log.d("MyApplication", "up[0] = " + up[0]);										//DEL@PROD
						Log.d("MyApplication", "up[1] = " + up[1]);										//DEL@PROD
					}																					//DEL@PROD
				}																						//DEL@PROD
				if (userName != null && userPass != null) {												//DEL@PROD
					handler.proceed(userName, userPass);												//DEL@PROD
				} else {																				//DEL@PROD
					showHttpAuthDialog(handler, host, realm);											//DEL@PROD
        		}																						//DEL@PROD
// Digest認証＆Basic認証－入力ダイアログ表示版 end														//DEL@PROD
				}																						//DEL@PROD
// ダイジェスト認証-入力ダイアログ非表示版（裏で認証） end												//DEL@PROD
																										//DEL@PROD
        	@Override
        	public boolean shouldOverrideUrlLoading (WebView view, String url) {
        		Log.d("MyApplication", "shouldOverrideUrlLoading() url=" + url);
// ADD-ST #24901:【PUSH通知】自宅設定画面の表示イメージの調査 PSDCD徐 2015-12-24
				if (url.startsWith("https://maps.google.com") || url.startsWith("https://www.google.com")) {
					//まずはロードを止める。
					view.stopLoading();

					Intent intent = new Intent();
					intent.setAction(Intent.ACTION_VIEW);
					Log.d("MyApplication", "open by browser: "+url);
					intent.setData(Uri.parse(url));
					try {
						startActivity(intent);
					} catch	(Exception e) {
						Log.e("MyApplication", "Exception: " + e);
						e.printStackTrace();
						// ブラウザの起動に失敗した場合
						String message = "ブラウザが起動できませんでした";
						Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
					}
					return true;
				}
// ADD-ED #24901:【PUSH通知】自宅設定画面の表示イメージの調査 PSDCD徐 2015-12-24
        		//独自URL処理
        		//	psshttp(s):	 標準ブラウザで開く/クラパナオートログインなし
        		//	pss2http(s): 標準ブラウザで開く/クラパナオートログインあり
        		//  pss3http(s): WebViewで開く/クラパナオートログインあり
        		//  pss4http(s): 標準ブラウザで開く/Web修理受付オートログインあり
        		//  pss5http(s): 標準ブラウザで開く/パナセンス連携オートログイン(GET)あり
        		if (url.startsWith("pss")) {
        			//まずはロードを止める。
    				view.stopLoading();
        			//スキームが"pss2"または"pss3"または"pss4"で始まる場合はオートログイン処理を行う。
        			if (url.startsWith("pss2") || url.startsWith("pss3") || url.startsWith("pss4")) {
        				Log.d("MyApplication", "Open with autologin");
        				StringBuffer urlSB = new StringBuffer(url);
        				//先頭の"pss2"もしくは"pss3"を削除
        				urlSB.delete(0,4);
        				Log.d("MyApplication", "url(after)="+urlSB.toString());
        				//接続しているホストに紐づいたcookieを文字列で取得
        				String cookieStrings = cookieManager.getCookie("https://"+AUTH_HOST);
        				//String vrsAstring = null;	//DEL: TF-#4065 SSO方式変更
        				String vrsTstring = null;
        				Log.d("MyApplication", "cookieStrings=\""+cookieStrings+"\"");
//CHG-ST: TF-#4065: クラパナ・Web修理受付のSSOをGET方式に変更
        				if(cookieStrings != null) {
        					//「vrstoken」を取得
        					String[] oneCookieString = cookieStrings.split(";");
        					for (String nameAndValue : oneCookieString) {
        						nameAndValue = nameAndValue.trim();
        						String[] cookieSet = nameAndValue.split("=");
        						// Cookieを作成
       							if (cookieSet[0].startsWith("vrstoken")) {
        							vrsTstring = cookieSet[1];
        						}
        					}
        				}
        				if (url.startsWith("pss2") || url.startsWith("pss4")) {
        					// "pss2"または"pss4"で始まる場合は標準ブラウザで開く
        					String jumpUrl = urlSB.toString();
        					//トークンを付与
        					if (jumpUrl.indexOf("?") == -1) {
        						jumpUrl += "?";
        					} else {
        						jumpUrl += "&";
        					}
        					jumpUrl += "vrs_t=" + vrsTstring;
							//"pss4"で始まる場合かつ本番サーバ以外の場合は「vrs_s」(アクセス元ステージング環境)を付与する。	//DEL@PROD
    						if(url.startsWith("pss4") && (AUTH_HOST.equals(PROD_HOST) == false)) { 		//DEL@PROD
    							String vrsSstring = null;												//DEL@PROD
    							if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":443")) {						//DEL@PROD
    								vrsSstring = "STG1";												//DEL@PROD
    							} else if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":10443")) {				//DEL@PROD
    								vrsSstring = "STG2";												//DEL@PROD
    							} else if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":20443")) {				//DEL@PROD
    								vrsSstring = "STG3";												//DEL@PROD
    							} else if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":30443")) {				//DEL@PROD
    								vrsSstring = "STG4";												//DEL@PROD
    							} else if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":40443")) {				//DEL@PROD
    								vrsSstring = "STG5";												//DEL@PROD
    							} else if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":50443")) {				//DEL@PROD
    								vrsSstring = "STG6";												//DEL@PROD
    							}																		//DEL@PROD
    							jumpUrl += "&vrs_s="+vrsSstring;										//DEL@PROD
    						}																			//DEL@PROD
    						//TODO: 「form=gmApp」補完の今後については要検討
    						if(url.startsWith("pss2") && url.indexOf("from=gmApp") == -1) {
    							jumpUrl += "&from=gmApp";
    						}
        					//"pss2","pss4"で始まる場合は標準ブラウザで開く
        					Intent intent = new Intent();
        					//DEL-ST:TF-#5622 2012/11/13 (山形)
        					//intent.setClassName("com.android.browser", "com.android.browser.BrowserActivity");
        					//DEL-ED:TF-#5622 2012/11/13 (山形)
        					intent.setAction(Intent.ACTION_VIEW);
        					Log.d("MyApplication", "open by browser: "+jumpUrl);
        					intent.setData(Uri.parse(jumpUrl));
        					//CHG-ST:TF-#5622 2012/11/13 (山形)
        					try {
        						startActivity(intent);
        					} catch	(Exception e) {
        						Log.e("MyApplication", "Exception: " + e);
        						e.printStackTrace();
        						// ブラウザの起動に失敗した場合
        						String message = "ブラウザが起動できませんでした";
        						Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
        					}
        					//CHG-ED:TF-#5622 2012/11/13 (山形)
        					return true;
        				} else {
        					// "pss3"で始まる場合はWebViewで開く
        					String jumpUrl = urlSB.toString();
        					//トークンを付与する
        					if (jumpUrl.indexOf("?") == -1) {
        						jumpUrl += "?";
        					} else {
        						jumpUrl += "&";
        					}
        					jumpUrl += "vrs_t=" + vrsTstring;
    						//TODO: 「form=gmApp」補完の今後については要検討
    						if(url.indexOf("from=gmApp") == -1) {
    							jumpUrl += "&from=gmApp";
    						}
        					Log.d("MyApplication", "open by webview: "+jumpUrl);
        					view.loadUrl(jumpUrl);
        					return true;
        				}
//CHG-ED: TF-#4065: クラパナ・Web修理受付のSSOをGET方式に変更
        			} else if (url.startsWith("pss5")) {
        				//スキームが"pss5"で始まる場合は、
        				//　①「CTSESSION」をURLエンコードしてクエリに設定
        				//　②「pss5」を外したURLを「PSS5URL」としてクエリに設定
        				//を行った上で、標準ブラウザに渡す。
        				//アクセス先では、「CTSESSION」を切り出し、標準ブラウザに対してset-cookieを実行した上で、
        				//「PSS5URL」で指定されたURLに飛ばす。
        				//(端末ストレージ内のファイルから外部ドメインに対するset-cookieを実行できないため)
        				Log.d("MyApplication", "Open by BROWSER(pss5)");
        				StringBuffer urlSB = new StringBuffer(url);
        				urlSB.delete(0,4); //先頭の"pss5"を削除
// CHG-ST [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
        				//「CSI」(新システム)/「CTSESSION」(旧システム)のどちらが来ても処理させる
        				String cookieName = "CSI";
        				int urlCookiePos = urlSB.indexOf("&"+cookieName+"=");
        				if (urlCookiePos < 0) {
        					cookieName = "CTSESSION";
        					urlCookiePos = urlSB.indexOf("&"+cookieName+"=");
        				}
// CHG-ED [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
        				//CTSESSIONをURLエンコードする。
        				String cookieString;
						try {
// CHG-ST [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
// CHG-ST [欠陥管理 TF-#20897] 【PanasonicStore連携】新サーバにSSOする際のtokenが一部欠落している
							cookieString = "&"+cookieName+"="+java.net.URLEncoder.encode(urlSB.substring(urlCookiePos+cookieName.length()+2), "UTF-8");
// CHG-ED [欠陥管理 TF-#20897] 【PanasonicStore連携】新サーバにSSOする際のtokenが一部欠落している
// CHG-ED [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
						} catch (UnsupportedEncodingException e) {
				        	Log.e("MyApplication", "UnsupportedEncodingException: " + e);
							e.printStackTrace();
// CHG-ST [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
							cookieString = "&"+cookieName+"=";
// CHG-ED [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
						}
						//urlSBから「&CTSESSION=～」を削除
						urlSB.delete(urlCookiePos, urlSB.length());
// CHG-ST [欠陥管理 TF-#20897] 【PanasonicStore連携】新サーバにSSOする際のtokenが一部欠落している
        				Log.d("MyApplication", "pss5: url(after)="+urlSB.toString()+cookieString);
// CHG-ED [欠陥管理 TF-#20897] 【PanasonicStore連携】新サーバにSSOする際のtokenが一部欠落している
// ADD-ST [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
        				Log.d("MyApplication", "pss5: cookieName=\""+cookieName+"\"");
// ADD-ED [仕様変更作業管理 TF-#20737] 【携帯アプリ】 次期 Panasonic Store 対応
        				Log.d("MyApplication", "pss5: cookieStrings=\""+cookieString+"\"");
        				//飛び先URL＋クエリを丸ごとURLエンコードする。
						String redirectString;
						try {
							redirectString = "?PSS5URL="+java.net.URLEncoder.encode(urlSB.toString(), "UTF-8");
						} catch (UnsupportedEncodingException e) {
				        	Log.e("MyApplication", "UnsupportedEncodingException: " + e);
							e.printStackTrace();
							redirectString = "?PSS5URL=";
						}
        				Intent intent = new Intent();
    					//DEL-ST:TF-#5622 2012/11/13 (山形)
        				//intent.setClassName("com.android.browser", "com.android.browser.BrowserActivity");
    					//DEL-ED:TF-#5622 2012/11/13 (山形)
        				intent.setAction(Intent.ACTION_VIEW);
        				//URLを組み立て直す
        				String hostString;
						if (AUTH_HOST_PORT1.equals(AUTH_HOST + ":443")) {
							hostString = AUTH_HOST;
						} else {
							hostString = AUTH_HOST_PORT1;
						}
						String urlString = "https://" + hostString + "/dynamic/public/redirect.html" + redirectString + cookieString;
    					intent.setData(Uri.parse(urlString));
        				Log.d("MyApplication", "pss5: open by browser: "+urlString);
    					//CHG-ST:TF-#5622 2012/11/13 (山形)
        				try {
        					startActivity(intent);
        				} catch	(Exception e) {
        					Log.e("MyApplication", "Exception: " + e);
        					e.printStackTrace();
        					// ブラウザの起動に失敗した場合
        					String message = "ブラウザが起動できませんでした";
        					Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
        				}
        				//CHG-ED:TF-#5622 2012/11/13 (山形)
					} else if (url.startsWith("pss")) {
        				//スキームが"pss"で始まる場合は"pss"を削ってブラウザで開く
        				view.stopLoading();
        				Log.d("MyApplication", "Open by BROWSER(new)");
        				StringBuffer urlSB = new StringBuffer(url);
        				urlSB.delete(0,3); //先頭の"pss"を削除
        				Log.d("MyApplication", "url(after)="+urlSB.toString());
        				Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(urlSB.toString()));
    					//CHG-ST:TF-#5622 2012/11/13 (山形)
        				try {
        					startActivity(intent);
        				} catch	(Exception e) {
        					Log.e("MyApplication", "Exception: " + e);
        					e.printStackTrace();
        					// ブラウザの起動に失敗した場合
        					String message = "ブラウザが起動できませんでした";
        					Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
        				}
        				//CHG-ED:TF-#5622 2012/11/13 (山形)
        			}
        			return true;
        		} else if (url.startsWith("tel:")) {
        			//2012/03/16 電話発信対応 add start
        			// "tel:"で始まるURLはWebViewで開かない
        			Log.i("MyApplication", "Phone Call");
        			view.stopLoading();
        			Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
   					//CHG-ST:TF-#5622 2012/11/13 (山形)
    				try {
    					startActivity(intent);
    				} catch	(Exception e) {
    					Log.e("MyApplication", "Exception: " + e);
    					e.printStackTrace();
    					// ブラウザの起動に失敗した場合
    					String message = "ブラウザが起動できませんでした";
    					Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
    				}
    				//CHG-ED:TF-#5622 2012/11/13 (山形)
        			return true;
        			//2012/03/16 電話発信対応 add end
        		} else if (url.startsWith("mailto:")) {
   					//ADD-ST:PAD-#11267 クラパナ会員登録の空メール対応 2013/05/17 ohtani
        			Log.i("MyApplication", "Mailer Start");
        			//URLデコード
        			String decodedURL;
        			try {
        				decodedURL = java.net.URLDecoder.decode(url.toString(), "UTF-8");
        			} catch (Exception e) {
        				Log.d("MyApplication", "url: decode failed");
        				e.printStackTrace();
        				decodedURL = null;
        			}
    				Log.e("MyApplication", "decodedURL: "+ decodedURL);
        			//新規生成
        			Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(url));
        			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    				try {
    					startActivity(intent);
    				} catch	(Exception e) {
    					Log.e("MyApplication", "Exception: " + e);
    					e.printStackTrace();
    					// Mailerの起動に失敗した場合
    					String message = "Mailerが起動できませんでした";
    					Toast.makeText(view.getContext(), message, Toast.LENGTH_LONG).show();
    				}
        			return true;
   					//ADD-ED:PAD-#11267 クラパナ会員登録の空メール対応 2013/05/17 ohtani
        		} else {
        			Log.d("MyApplication", "load WebView");
        			//2012/07/19:欠陥管理#3815対応:不要なCSRF対策コードを削除
        			return false;
        		}
        	}

        	@Override
        	public void onPageStarted (WebView view, String url, Bitmap favicon) {
        		Log.i("MyApplication", "onPageStarted() url=" + url);

        		// 自動消灯をON
        		sleepScreenOn();

        		// "tel","pss","pss2","pss3"の処理はshouldOverrideUrlLoadingへ移動
                // こっちに渡ってきてしまった場合は、shouldOverrideUrlLoadingを呼んで前ページに戻す。
        		if (url.startsWith("pss")||url.startsWith("tel")) {
                    Log.d("MyApplication", "stopLoading & shouldOverrideUrlLoading");
                    view.stopLoading();
                    view.clearView(); //エラー画面が見えてしまう場合があるためガード
                    this.shouldOverrideUrlLoading(view, url);

                    // WebView.goBack()は使わず、明示的に遷移(loadUrl)する
                    WebBackForwardList list = view.copyBackForwardList();
    				final int listCount = list.getSize();
                    for (int i = 0; i < listCount; i++) {
                        WebHistoryItem history = list.getItemAtIndex(listCount - i - 1);
                        String returnUrl = history.getUrl();
                        Log.d("MyApplication", "history url=" + returnUrl);
                        if (!returnUrl.startsWith("pss")) {
                            view.loadUrl(returnUrl);
                            break;
                        }
                    }
                    //view.goBack();
                    return;
                }

        		// TF-#2917 対応 onPageStarted開始
        		// ここからonPageFinishの間にjsWindowOnErrorが発生すると、システムエラーとする。
       			isPageLoading = true;
        		// エラーを先勝ちにするため、
       			isJsError = false;

       			/* TF-#4508 画面読込時にダイアログが残っている場合は、強制的に閉じる。 */
       			closeInputDialog();


	       		if (isNoMenuHtml(url)) {
					// アプリケーションメニューを表示不可にリセットする。
					setSupportApplicationMenuFlg( false );
       			} else {
					// アプリケーションメニューを表示可にリセットする。
					setSupportApplicationMenuFlg( true );
       			}

	       		// 読み込み中ダイアログ表示
        		if (!isNoDialogHtml(url)) {
//DEL-ST PAD-#11726
//DEL-EN PAD-#11726
        			// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
        			pageTransactionFlag = true;
        			openProgressDialogInner();
        		}
        		// レスポンスがない場合、タイムアウトする対応
        		if (mRespTimer == null) {
        			mRespTimer = new Timer(true);
        			mRespTimer.schedule( new TimerTask() {
        				@Override
        				public void run() {
        					mRespHandler.post( new Runnable() {
        						public void run() {
        							// タイムアウト処理
        							Log.d("MyApplication", "onPageStarted() Timeout");
        							if(mWaitDialog != null){
        								mWaitDialog.dismiss();
        								mWaitDialog = null;
        							}

        							closeSplashImage();

//        							wv.loadUrl("file:///android_asset/www/err/12a/err_11.html");
        							loadErrUrl(
        								SYSTEM_ERR_CODE_G_11292_30002,
    									ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("ERR_MESSAGE"),
    									ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("BTN_NAME")
        							);
        						}
        					});
        				}
        			}, RESPONSE_TIMEOUT);
        		}
        	}

        	@Override
        	public void onPageFinished (WebView view, String url) {
        		Log.i("MyApplication", "onPageFinished() url=" + url);
        		// cookieを保存
        		cookieSyncManager.sync();

        		// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
        		pageTransactionFlag = false;

        		// 読み込み中ダイアログをクローズ
        		closeProgressDialog();
        																								//DEL@PROD
        		// デバッグ情報（画面URL）を登録する													//DEL@PROD
        		DebugInfo.getInstance().setDebugInfo("画面URL", "URL", url);							//DEL@PROD

        		// TF-#2917 対応 読み込み終了
        		isPageLoading = false;

        		if (mRespTimer != null) {
        			mRespTimer.cancel();
        			mRespTimer = null;
        		}

        		// PAD-#7881 にて追加
        		// 強制再描画を試みる。
        		Handler handler = wv.getHandler();
        		if (handler == null) {
        			Log.d("MyApplication", "handler == null");
        		} else {
	        		handler.post(new Runnable() {
						public void run() {
							((GWebView)wv).forceContentDraw();
						}
					
	    			});
        		}

        		// アップデート通知ダイアログ表示が保留されている場合は表示
        		if (mNotifyUpdatePendingIntent != null) {
        			Log.d("MyApplication", "Send intent to notify update.");
        			view.getContext().sendBroadcast(mNotifyUpdatePendingIntent);
        			mNotifyUpdatePendingIntent = null;
        		}
        	}

        	// PMCRD PATCH
        	@Override
        	public void onLoadResource(WebView view, String url) {
        		Log.i("MyApplication", "onLoadResource() url=" + url);
        		super.onLoadResource(view, url);
        	}

			@Override
			public void onScaleChanged (WebView view, float oldScale, float newScale) {
			    Log.d("MyApplication", "onScaleChanged : oldScale = '" + oldScale + "'");
			    Log.d("MyApplication", "onScaleChanged : newScale = '" + newScale + "'");
			    super.onScaleChanged(view, oldScale, newScale);
				// スケール変更された画面を表示しないようにクリアする。
			    Log.d("MyApplication", "onScaleChanged : clearView");
				view.clearView();
				// スケール変更を反映するため、再ロードする。
			    Log.d("MyApplication", "onScaleChanged : reload");
				view.reload();
			}
        });
// SSLエラー暫定対応 add end

        // 効果音リソースをロードする（必ずonCreate内で行うこと）
    	loadSound();
    	// TF-#3853 当メソッドが実行した結果を何処でも使っていない。
    	// 起動直後のjavascriptエラーの原因となっているので削除
        // ネットワーク状態、WiFi設定状態を設定する
        // int iState = Util.checkNetworkState(this);
        // jsB.notifyNetworkState(iState);
	    boolean bState = Util.checkWifiState(this);
	    jsB.notifyWifiState(bState);

		// 起動後のネットワーク状態、WiFi設定状態の受信処理
		nwReceiver = new BroadcastReceiver() {
			@Override
			public void onReceive(Context context, Intent intent) {

				String action = intent.getAction();

				// ネットワーク接続状態、または、WiFi設定状態が変更された場合
				if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION) ||
					action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
					Log.i("MyApplication", "NetworkReceiver onReceive()");
			        // キャッシュクリア処理は不要として削除
					// wv.clearCache(true);

					// ネットワーク断かつタッチ画面の場合はエラー
					if (Util.checkNetworkState(context) == 0 && isEnableNfc != DISABLE_NFC) {
//						wv.loadUrl("file:///android_asset/www/err/12a/err_10.html");

						disableNfc();
						loadErrUrl(
							SYSTEM_ERR_CODE_G_11292_30001,
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("ERR_MESSAGE"),
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("BTN_NAME")
						);
					}
				}
			}
		};
		IntentFilter nfilter = new IntentFilter();
		nfilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
		nfilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
		registerReceiver(nwReceiver, nfilter);

        // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-19
        // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-26
        dlReceiver = new FileDownloadReceiver();
        // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-26
        IntentFilter dlFilter = new IntentFilter();
        dlFilter.addAction(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
        registerReceiver(dlReceiver, dlFilter);
        // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-19

        // 端末音量設定の準備
        //DEL-ST 欠陥管理#8722
        //myAudioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
        //DEL-ED 欠陥管理#8722

		// 効果音の音量を設定する
    	float volume = jsB.getTouchVolume();
    	setSoundVolume(volume);

    	// PMCRD PATCH
    	// FrameLayoutの登録
    	setContentView(layout);

        // Long Tap(長押し)無効化
        wv.setOnLongClickListener(new OnLongClickListener() {
        	@Override
        	public boolean onLongClick(View view) {
        		Log.d("MyApplication", "Long tap is disabled!!");
        		return true;
        	}
        });

// 2012/02/13 URLスキーム暫定対応 add start
    	Intent intent = getIntent();
        String action = intent.getAction();

        int flags = intent.getFlags();
        boolean isFromHistory = false;
        if ((flags & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) {
            // 起動履歴から起動した場合
            isFromHistory = true;
        }
        Log.d("MyApplication", "FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY@onCreate="+isFromHistory);
        Log.d("MyApplication", "CATEGORIES@onCreate="+intent.getCategories());
        Log.d("MyApplication", "ACTION@onCreate="+action);

        if (Intent.ACTION_VIEW.equals(action)) {
        	// ブラウザから起動された場合
        	// actionには「android.intent.action.VIEW」が設定されます
        	Uri uri = intent.getData();
            // uriには、ブラウザで設定した「sample://arg1=123&arg2=abc」が設定されます
            Log.d("MyApplication", "Kicked from Browser: uri = [" + uri.toString() + "]");
            // 飛び先IDの文字列取得
// MOD-ST [欠陥管理 TF-#10401]【SNS連携】Panasonic Cooking「牛肉100%ハンバーグ」のレシピの投稿からお気に入り登録すると、「G-11292-30104」が発生する
//　MOD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
            //String gotoId = uri.getHost();
            //String gotoId = uri.getEncodedAuthority();
            String gotoId;
            if (intent.hasExtra("goto")) {
            	// extraDataで指定されている場合はそちらを優先
            	try {
					gotoId = java.net.URLEncoder.encode(intent.getStringExtra("goto"), "UTF-8");
					Log.d("MyApplication", "set from extraData. (goto)");
				} catch (UnsupportedEncodingException e) {
					Log.d("MyApplication", "URL encode failed. (goto)");
					e.printStackTrace();
					gotoId = "";
				}
            } else {
				Log.d("MyApplication", "not found in extraData. (goto)");
            	gotoId = uri.getEncodedAuthority();
            	// Chromeからのintent起動の場合、gotoIdの末尾に":"が付与されるため除去する。
//CHG-ST [欠陥管理 TF-#20721] PSAのお気に入り一覧から「HEMS」を選択し、HEMS画面をブラウザで表示後、「戻る」押下するとPSAが落ちる。
            	if ((gotoId.length() > 0) && (gotoId.indexOf(":") == (gotoId.length() - 1))) {
//CHG-ED [欠陥管理 TF-#20721] PSAのお気に入り一覧から「HEMS」を選択し、HEMS画面をブラウザで表示後、「戻る」押下するとPSAが落ちる。
            		Log.d("MyApplication", "chop \":\" from gotoId");
            		gotoId = gotoId.substring(0, gotoId.length() - 1);
            	}
            }
//　MOD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
// MOD-ED [欠陥管理 TF-#10401]【SNS連携】Panasonic Cooking「牛肉100%ハンバーグ」のレシピの投稿からお気に入り登録すると、「G-11292-30104」が発生する
//3rd party連携 add start
// MOD-ST [欠陥管理 TF-#17349]【携帯プリ】 新レシピ タッチ機能の開発　キッチンポケットからの起動時、PSAでパラメータを取得できない
            //String query = uri.getQuery();
            String query;
            if("EXTTCH0010".equals(gotoId)){
                // キッチンポケットの場合
                query = uri.getEncodedQuery();
//　MOD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
                // キッチンポケット連携のパラメータがextraDataに指定されていたら追加 (欠陥管理 TF-#17946)
                if (intent.hasExtra("recipe_name")) {
                	try {
						query = "recipe_name=" + java.net.URLEncoder.encode(intent.getStringExtra("recipe_name"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (recipe_name)");
                	} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode failed. (recipe_name)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (recipe_name)");
                }
                if (intent.hasExtra("recipedata")) {
                	try {
						query = "recipedata=" + java.net.URLEncoder.encode(intent.getStringExtra("recipedata"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (recipedata)");
					} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode faild. (recipedata)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (recipedata)");
                }
//　MOD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
// ADD-ST #12713:【事前検討】15夏おやすみナビ対応 PSDCD肖 2015-02-06
            } else if("ACMEST001".equals(gotoId)){
                // おやすみナビからどこでもリモコン画面に遷移の場合
                query = uri.getEncodedQuery();
                if (intent.hasExtra("appliance_id")) {
                	try {
						query = "appliance_id=" + java.net.URLEncoder.encode(intent.getStringExtra("appliance_id"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (appliance_id)");
                	} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode failed. (appliance_id)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (appliance_id)");
                }
// ADD-ED #12713:【事前検討】15夏おやすみナビ対応 PSDCD肖 2015-02-06
            } else {
                // TODO [仕様変更管理 TF-#18092] 他のアプリ連携でのextraDataの扱いは別途検討
                query = uri.getQuery();
            }
// MOD-ED [欠陥管理 TF-#17349]【携帯プリ】 新レシピ タッチ機能の開発　キッチンポケットからの起動時、PSAでパラメータを取得できない
//　ADD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
            if(intent.hasExtra("fedauth")) {
            	query = "fedauth=" + intent.getStringExtra("fedauth") + "&" + query;
				Log.d("MyApplication", "set from extraData. (fedauth)");
            } else {
				Log.d("MyApplication", "not found in extraData. (fedauth)");
            }
//　ADD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
//3rd party連携 add end
            Log.d("MyApplication", "Kicked from Browser: gotoId = [" + gotoId + "]");
//3rd party連携 add start
            Log.d("MyApplication", "Kicked from Browser: query = [" + query + "]");
//3rd party連携 add end
// ADD-ST [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
//            // 飛び先画面を表示
//            String loginUrl = GEMINI_LOGIN_URL + gotoId + "&_=" + Math.random();
//            Log.d("MyApplication", "GEMINI_LOGIN_URL = " + loginUrl);
            String loginUrl;
            Pattern pattern = Pattern.compile("^SCURL.*");
            Matcher matcher = pattern.matcher(gotoId);
            boolean isScurl= matcher.matches();

            pattern = Pattern.compile("^SCUXPORTAL.*");
            matcher = pattern.matcher(gotoId);
            boolean isScuxportal= matcher.matches();
            Log.d("MyApplication", "isScurl = " + isScurl);
            Log.d("MyApplication", "isScuxportal = " + isScuxportal);
            if( isFromHistory ){
			    // 起動履歴から起動した場合、通常起動へ置き換える
                loginUrl = "file:///android_asset/www/portal/12a/begin.html";
                Log.d("MyApplication", "isFromHistory. change to GEMINI_LOGIN_URL = " + loginUrl);
            }else if( isScurl || isScuxportal ){
                // タスクマネージャから起動した場合、最後のURLスキームでアプリを起動しようとするよう。
                // アプリ起動時(onCreateイベント)にショートカットを実行するケースが無いので、通常起動へ置き換える
                //loginUrl = GEMINI_SCURL_URL + gotoId + "&_=" + Math.random();
                loginUrl = "file:///android_asset/www/portal/12a/begin.html";
                Log.d("MyApplication", "change to GEMINI_SCURL_URL = " + loginUrl);
//3rd party連携 change start
            }else if ((query != null) && (!(query.equals("")))) {
        		loginUrl = GEMINI_LOGIN_URL + gotoId + "&" + query + "&_=" + Math.random();
        		Log.d("MyApplication", "loginUrl = " + loginUrl);
        	}else{
//3rd party連携 change end
                loginUrl = GEMINI_LOGIN_URL + gotoId + "&_=" + Math.random();
                Log.d("MyApplication", "GEMINI_LOGIN_URL = " + loginUrl);
            }
// ADD-ED [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
            if((gotoId == null) || gotoId.equals("")) {
                // 画面IDが指定されていない場合は通常起動
                loginUrl = "file:///android_asset/www/portal/12a/begin.html";
                Log.d("MyApplication", "change to GEMINI_LOGIN_URL = " + loginUrl);
				wv.loadUrl(loginUrl);
            } else {
				wv.loadUrl(loginUrl);
			}
         } else if((Intent.ACTION_MAIN.equals(action)) || (isFromHistory == true)){
// 2012/02/13 URLスキーム暫定対応 add start
        	 // 通常起動の場合
        	 // ローカル画面URLの設定
        	 String url = "file:///android_asset/www/portal/12a/begin.html";

        	 Log.d("MyApplication", "onCreate() loadUrl:" + url);
        	 wv.loadUrl(url);
// ADD-ST 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
         } else if (action.equals(ACTION_PUSH_MESSAGE_GCM)) {
			 // PUSH通知サービス種別 
			 String serviceID = intent.getStringExtra(PUSH_RECEIVE_SERVICE_ID);
			 // 機器ＩＤ
			 String applianceID = intent.getStringExtra(PUSH_RECEIVE_APPLIANCE_ID);
			 // ポップアップ表示用メッセージ
			 String alertMsg = intent.getStringExtra(PUSH_RECEIVE_MESSAGE);
	       	 
			 loadPushPopUrl(serviceID, applianceID, alertMsg);
// ADD-ED 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
// 2012/02/13 URLスキーム暫定対応 add start
         }
// 2012/02/13 URLスキーム暫定対応 add end
		// PMCRD PATCH
		// WebViewの上にスプラッシュイメージを配置
		splashImage = new ImageView(this);
		splashImage.setImageResource(R.drawable.splash);
		splashImage.setScaleType(ScaleType.CENTER_CROP);
		layout.addView(splashImage, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
		splashStart = java.lang.System.currentTimeMillis();
		//プレビュー版はすぐにスプラッシュを消去
		if (isPreviewApp) {
			closeSplashImage();
		}

		// バージョンチェック関連
		mNotifyUpdatePendingIntent = null;
//DEL-ST PAD-#11726
//DEL-EN PAD-#11726

		// Sns連携用設定
		mSns = new SnsWrapper(this);
		jsB.setSnsWrapper(mSns);
																										//DEL@PROD
		// デバッグ情報（動作フラグ）を登録する															//DEL@PROD
		setDebugInfo();																					//DEL@PROD
// DEL-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
// DEL-ED #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
    }

    // ハードウェアキーをハンドリングしてJavascriptで対応する
    @Override
    public boolean dispatchKeyEvent(KeyEvent e){
        // Backキー
    	if (e.getKeyCode() == KeyEvent.KEYCODE_BACK) {
    		if (e.getAction() == KeyEvent.ACTION_DOWN) {
            	jsB.notifyGoBack();
    		}
    		return true;
    	} else if (e.isLongPress() && e.getKeyCode() == KeyEvent.KEYCODE_MENU){
    		//MENUキー長押下を無視する。(P-02D対応)
    		Log.d("MyApplication", "Ignore LongPress MENU Key");
    		return true;
    	}

    	if (e.getKeyCode() == KeyEvent.KEYCODE_MENU) {
	        if( supportApplicationMenuFlg ) {
	        	return super.dispatchKeyEvent(e);
	        } else {
	    		Log.d("MyApplication", "No Menu Page!");
	        	return true;
	        }
    	} else {
        	return super.dispatchKeyEvent(e);
    	}

    }

// 開発時用RELOAD/EXITメニュー実装 add start
    private static final int MENU_ID_MENU1 = (Menu.FIRST + 1);
    private static final int MENU_ID_MENU2 = (Menu.FIRST + 2);
    private static final int MENU_ID_MENU3 = (Menu.FIRST + 3);
    private static final int MENU_ID_MENU4 = (Menu.FIRST + 7);
    private static final int MENU_ID_MENU5 = (Menu.FIRST + 8);
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
    private static final int MENU_ID_MENU6 = (Menu.FIRST + 20);
    private static final int MENU_ID_MENU7 = (Menu.FIRST + 21);
    private static final int MENU_ID_MENU8 = (Menu.FIRST + 22);
    private static final int MENU_ID_MENU9 = (Menu.FIRST + 23);
// ADD-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
    private static final int MENU_ID_MENU10 = (Menu.FIRST + 24);
    private static final int MENU_ID_MENU11 = (Menu.FIRST + 25);
    private static final int MENU_ID_MENU12 = (Menu.FIRST + 26);
    private static final int MENU_ID_MENU13 = (Menu.FIRST + 27);
    private static final int MENU_ID_MENU14 = (Menu.FIRST + 28);
    private static final int MENU_ID_MENU15 = (Menu.FIRST + 29);
    private static final int MENU_ID_MENU16 = (Menu.FIRST + 30);
    private static final int MENU_ID_MENU17 = (Menu.FIRST + 31);
    private static final int MENU_ID_MENU18 = (Menu.FIRST + 32);
    private static final int MENU_ID_MENU19 = (Menu.FIRST + 33);
    private static final int MENU_ID_MENU20 = (Menu.FIRST + 34);
// ADD-ST #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
    private static final int MENU_ID_MENU21 = (Menu.FIRST + 35);
    private static final int MENU_ID_MENU22 = (Menu.FIRST + 36);
    private static final int MENU_ID_MENU23 = (Menu.FIRST + 37);
    private static final int MENU_ID_MENU24 = (Menu.FIRST + 38);
// ADD-ED #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
//ADD-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷		
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李	
    private static final int MENU_ID_MENU25 = (Menu.FIRST + 39);
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
    // アプリログ抜き出し追加
    private static final int MENU_ID_END = (Menu.FIRST + 6);
    // 戻る
    private static final int MENU_ID_BACK = (Menu.FIRST + 4);
    // 情報																								//DEL@PROD
    private static final int MENU_ID_INFO = (Menu.FIRST + 5);   // PAD-#10013							//DEL@PROD
// ADD-START TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
    // APサーバ接続先設定																				//DEL@PROD
    private static final int MENU_ID_APSERVER_CONFIG = (Menu.FIRST + 9);								//DEL@PROD
    private static final int MENU_ID_USE_AP_STG1 = (Menu.FIRST + 10);									//DEL@PROD
    private static final int MENU_ID_USE_AP_STG2 = (Menu.FIRST + 11);									//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
    // AP2サーバ接続先設定																				//DEL@PROD
    private static final int MENU_ID_AP2SERVER_CONFIG = (Menu.FIRST + 12);								//DEL@PROD
    private static final int MENU_ID_USE_AP2_STG1 = (Menu.FIRST + 13);									//DEL@PROD
    private static final int MENU_ID_USE_AP2_STG2 = (Menu.FIRST + 14);									//DEL@PROD
// ADD-ST #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
	private Menu mMenu;
// ADD-ED #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
 // ADD-END  TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
    // オプションメニューが最初に呼び出される時に1度だけ呼び出されます
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
		Log.d("MyApplication", "createMenu");
// ADD-ST #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
		if (android.os.Build.VERSION.SDK_INT >= 24){
			mMenu = menu;
		}
// ADD-ED #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
        // メニューアイテムを追加します
		if (getParam("SNS_LIBRARY_LOAD").equals("true")) {
			// ライブラリのロードが成功している場合
	        SubMenu subMenu = menu.addSubMenu(0, MENU_ID_MENU3, 0, "SNS設定");
	        subMenu.setIcon(android.R.drawable.ic_menu_manage);
	        subMenu.add(Menu.NONE, MENU_ID_MENU4, Menu.NONE, "Facebook連携").setCheckable(true);
	        subMenu.add(Menu.NONE, MENU_ID_MENU5, Menu.NONE, "Twitter連携").setCheckable(true);
		}
        menu.add(Menu.NONE, MENU_ID_MENU1, Menu.NONE, "更新").setIcon(android.R.drawable.ic_popup_sync);
        menu.add(Menu.NONE, MENU_ID_MENU2, Menu.NONE, "終了").setIcon(android.R.drawable.ic_menu_close_clear_cancel);
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
        if ((getParam("PUSH_MESSAGE_SUPPORT").equals("true")) && (showPushBtnInMenu == true)) {
	        SubMenu subMenuPush = menu.addSubMenu(0, MENU_ID_MENU6, 0, "PUSH");
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU7, Menu.NONE, "高温通知");
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU17, Menu.NONE, "低温通知");
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU18, Menu.NONE, "切り忘れ通知");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU19, Menu.NONE, "CS_turnon");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU20, Menu.NONE, "CS_dereference");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU8, Menu.NONE, "Alert_powerrate_00001");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU9, Menu.NONE, "Alert_powerrate_00002");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU10, Menu.NONE, "Alert_powerrate_00003");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU14, Menu.NONE, "Alert_convenience_00001");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU15, Menu.NONE, "Alert_convenience_00002");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU16, Menu.NONE, "Alert_applianceerror_00001");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU11, Menu.NONE, "Alert_monitoring_00001");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU12, Menu.NONE, "Alert_monitoring_00004");
//	        subMenuPush.add(Menu.NONE, MENU_ID_MENU13, Menu.NONE, "Alert_monitoring_00005");
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
// CHG-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
        }
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
// ADD-ST #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
        if ((getParam("PUSH_MESSAGE_SUPPORT").equals("true")) && (showThresholdSetBtnInMenu == true)) {
	        SubMenu subMenuPush = menu.addSubMenu(0, MENU_ID_MENU21, 0, "閾値設定");
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU22, Menu.NONE, "1分");
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU23, Menu.NONE, "10分");
	        subMenuPush.add(Menu.NONE, MENU_ID_MENU24, Menu.NONE, "1時間");
        }
// ADD-ED #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
        if ((getParam("PUSH_MESSAGE_SUPPORT").equals("true")) && (showPositionInfoInMenu == true)) {
        	menu.add(Menu.NONE, MENU_ID_MENU25, Menu.NONE, "位置情報");
        }
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
        if (Log.IS_DEBUGGABLE) {
        	if (Log.IS_USE_CUSTOM) {
        		menu.add(Menu.NONE, MENU_ID_END, Menu.NONE, "LOG2SD");
        	}
        	menu.add(Menu.NONE, MENU_ID_BACK, Menu.NONE, "戻る");
        	menu.add(Menu.NONE, MENU_ID_INFO, Menu.NONE, "INFO");  // PAD-#10013						//DEL@PROD
        }
// ADD-START TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
		SubMenu apServerConfSubMenu = menu.addSubMenu("APサーバ接続先設定");							//DEL@PROD
		apServerConfSubMenu.setIcon(android.R.drawable.ic_menu_manage);									//DEL@PROD
		apServerConfSubMenu.add(MENU_ID_APSERVER_CONFIG, MENU_ID_USE_AP_STG1, Menu.NONE, "APサーバSTG1");	//DEL@PROD
		apServerConfSubMenu.add(MENU_ID_APSERVER_CONFIG, MENU_ID_USE_AP_STG2, Menu.NONE, "APサーバSTG2");	//DEL@PROD
		apServerConfSubMenu.setGroupCheckable(MENU_ID_APSERVER_CONFIG, true, true);						//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
// CHG-ST #23232:【使い方ガイド】STG1へのプロト開発 PSDCD肖　2015-09-08
        SubMenu ap2ServerConfSubMenu = menu.addSubMenu("AP2サーバ接続先設定");							        //DEL@PROD
        ap2ServerConfSubMenu.setIcon(android.R.drawable.ic_menu_manage);									//DEL@PROD
        ap2ServerConfSubMenu.add(MENU_ID_AP2SERVER_CONFIG, MENU_ID_USE_AP2_STG1, Menu.NONE, "AP2サーバSTG1");	//DEL@PROD
        ap2ServerConfSubMenu.add(MENU_ID_AP2SERVER_CONFIG, MENU_ID_USE_AP2_STG2, Menu.NONE, "AP2サーバSTG2");	//DEL@PROD
        ap2ServerConfSubMenu.setGroupCheckable(MENU_ID_AP2SERVER_CONFIG, true, true);						//DEL@PROD
// CHG-ED #23232:【使い方ガイド】STG1へのプロト開発 PSDCD肖　2015-09-08
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
// ADD-END  TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
        return  super.onCreateOptionsMenu(menu);
    }
    // オプションメニューアイテムが選択された時に呼び出されます
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        boolean ret = true;
        Log.i("MyApplication", "onOptionsItemSelected, id=" + item.getItemId());
        switch (item.getItemId()) {
        default:
            ret = super.onOptionsItemSelected(item);
            break;
        case MENU_ID_MENU1:
            // キャッシュをクリアしてリロード
        	// #7591 アプリトップのWebAPIキャッシュ化対応 (2012/07/10 NID小林)
        	jsB.clearApiCache(wv.getUrl());
            wv.clearCache(true);
            jsB.setonUnloadFuncFlg();
            wv.reload();
            ret = true;
            break;
        case MENU_ID_MENU2:
            // アプリ終了
        	showConfirmFinishDialog();
            ret = true;
            break;
// ADD-ST #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
		case MENU_ID_MENU3:
			Log.i("MyApplication", "onOptionsItemSelected, MENU_ID_MENU3");
			if (mMenu != null) {
				mMenu.close();
			}
			ret = true;
			break;
// ADD-ED #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
        case MENU_ID_MENU4:
            // Facebook連携ボタン押下：トグル実行
// ADD-ST #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
			if (mMenu != null) {
				mMenu.close();
			}
// ADD-ED #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
           if (SnsUtils.loadParam(this, SnsParams.FB_USERID) == null) {
                // OFF→ON：Facebookログイン
                mSns.facebookLogin(this);
            } else {
                // ON→OFF：Facebookログアウト
                mSns.facebookLogout();
            }
            ret = true;
            break;
        case MENU_ID_MENU5:
            // Twitter連携ボタン押下：トグル実行
// ADD-ST #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
			if (mMenu != null) {
				mMenu.close();
			}
// ADD-ED #27021:android N preview beta4について確認した不具合(Facebook連携)リ PSDCD肖　2016-08-08
            if (SnsUtils.loadParam(this, SnsParams.TW_USERID) == null) {
                // OFF→ON：Twitterログイン
                mSns.twitterLogin();
            } else {
                // ON→OFF：Twitterログアウト
                mSns.twitterLogout();
            }
            ret = true;
            break;
        case MENU_ID_END:
            // ログ書き出し
            if (Log.writeToSdLog(wv)) {
                Toast.makeText(this, "** Done, write App Log to SD **", Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(this, "** Can't write App Log to SD **", Toast.LENGTH_LONG).show();
            }
            ret = true;
            break;
        case MENU_ID_BACK:
            // 戻る
            wv.goBack();
        	ret = true;
            break;
        // ADD-ST: PAD-#10013																			//DEL@PROD
        case MENU_ID_INFO:																				//DEL@PROD
            {																							//DEL@PROD
// DEL-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
// DEL-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
            	showDebugInfoDialog();																	//DEL@PROD
            }																							//DEL@PROD
            break;																						//DEL@PROD
        // ADD-ED: PAD-#10013																			//DEL@PROD
// ADD-START TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
		case MENU_ID_USE_AP_STG1:																		//DEL@PROD
			setApServerConf(ExternalServiceUtil.AP_STG1_HTTP_PORT, ExternalServiceUtil.AP_STG1_HTTPS_PORT);	//DEL@PROD
			ret = true;																					//DEL@PROD
			break;																						//DEL@PROD
		case MENU_ID_USE_AP_STG2:																		//DEL@PROD
			setApServerConf(ExternalServiceUtil.AP_STG2_HTTP_PORT, ExternalServiceUtil.AP_STG2_HTTPS_PORT);	//DEL@PROD
			ret = true;																					//DEL@PROD
			break;																						//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
		case MENU_ID_USE_AP2_STG1:																		//DEL@PROD
			setAp2ServerConf(ExternalServiceUtil.AP2_STG1_HTTP_PORT, ExternalServiceUtil.AP2_STG1_HTTPS_PORT);	//DEL@PROD
			ret = true;																					//DEL@PROD
			break;																						//DEL@PROD
		case MENU_ID_USE_AP2_STG2:																		//DEL@PROD
			setAp2ServerConf(ExternalServiceUtil.AP2_STG2_HTTP_PORT, ExternalServiceUtil.AP2_STG2_HTTPS_PORT);	//DEL@PROD
			ret = true;																					//DEL@PROD
			break;																						//DEL@PROD
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
// ADD-END  TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
        case MENU_ID_MENU25:
//ADD-ST #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
          	positionDebugInfo();
//ADD-ED #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
        break;	
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
		case MENU_ID_MENU7:
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			// 「高温アラート：高温状態が続いています。」:CS_heatstroke
// CHG-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			// PUSH通知サービス種別
			String serviceID = "CS_heatstroke";
			// 機器ＩＤ
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			String applianceID = "abcde";
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			// ポップアップで表示するメッセージ
// CHG-ST #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			String message = "リビングエアコンの<br>設置されている部屋が<br>高温状態です。";
			String title = "エアコン高温通知（35℃）：リビングエアコン";
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
// CHG-ED #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
// CHG-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
            break;
	    case MENU_ID_MENU8:
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			// 「電気代アラート：照明電源がONのままです。」:Alert_powerrate_00001
// CHG-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			// PUSH通知サービス種別
			serviceID = "Alert_powerrate_00001";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			message = "リビングは不在の<br>ようですが照明が<br>ONのままです。<br><br>照明をOFFします<br>か？";																
			title = "電気代アラート：照明電源がONのままです。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}
			ret = true;
// CHG-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
	    	break;
		case MENU_ID_MENU9:
// CHG-ST #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			// 「電気代アラート：ホットカーペット電源がONのままです。」:Alert_powerrate_00002
			// PUSH通知サービス種別
// CHG-ED #21007:【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			serviceID = "Alert_powerrate_00002";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
// CHG-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
			message = "リビングは不在の<br>ようですがホット<br>カーペットがONの<br>ままです。<br><br>ホットカーペットを<br>OFFしますか？";
			title = "電気代アラート：ホットカーペット電源がONのままです。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
			break;
		case MENU_ID_MENU10:
			// 「電気代アラート：エアコン電源がONのままです。」:Alert_powerrate_00003
			// PUSH通知サービス種別
			serviceID = "Alert_powerrate_00003";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+8885556665";
			// ポップアップで表示するメッセージ
			message = "リビングは不在の<br>ようですがエアコ<br>ンがONのままです。<br><br>エアコンをOFFしま<br>すか？";
			title = "電気代アラート：エアコン電源がONのままです。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU11:
			// 「見守りアラート：おへやモニターに反応がありました。」:Alert_monitoring_00001
			// PUSH通知サービス種別
			serviceID = "Alert_monitoring_00001";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "深夜XX時におへ<br>やモニター反応が<br>ありました。<br><br>110番しますか？";
			title = "見守りアラート：おへやモニターに反応がありました。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU12:
			// 「見守りアラート：おへやモニターに反応がありました。」:Alert_monitoring_00004
			// PUSH通知サービス種別
			serviceID = "Alert_monitoring_00004";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "15時におへやモ<br>ニターに反応が<br>ありました<br><br>お子さんへが<br>帰宅したようです。";
			title = "見守りアラート：おへやモニターに反応がありました。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU13:
			// 「見守りアラート：おへやモニターに反応がありません。」:Alert_monitoring_00005
			// PUSH通知サービス種別
			serviceID = "Alert_monitoring_00005";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "15時におへやモ<br>ニターに反応が<br>ありませんでした<br><br>お子さんへ<br>電話しますか。";
			title = "見守りアラート：おへやモニターに反応がありません。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU14:
			// 「エアコンからお知らせ：室外の方が涼しくなりました。」:Alert_convenience_00001
			// PUSH通知サービス種別
			serviceID = "Alert_convenience_00001";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "室外の方が涼し<br>くなりました。<br><br>エアコンをOFFしますか?</p>";
			title = "エアコンからお知らせ：室外の方が涼しくなりました。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU15:
			// 「エアコンからお知らせ：xx分後に運転停止します。」:Alert_convenience_00002
			// PUSH通知サービス種別
			serviceID = "Alert_convenience_00002";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "xx分後に運転停<br>止します。<br><br>切タイマーを更新しますか？";
			title = "エアコンからお知らせ：xx分後に運転停止します。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU16:
			// 「家電異常アラート：お使いの家電でエラーが発生しています。」:Alert_applianceerror_00001
			// PUSH通知サービス種別
			serviceID = "Alert_applianceerror_00001";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "エアコンで異常が<br>発生しています。<br><br>詳細を確認しますか？";
			title = "家電異常アラート：お使いの家電でエラーが発生しています。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU17:
			// 「高温アラート：室内温度が下がりました。」:CS_lowtemp
			// PUSH通知サービス種別
			serviceID = "CS_lowtemp";
			// 機器ＩＤ
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			applianceID = "abcde";
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			// ポップアップで表示するメッセージ
// CHG-ST #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
			message = "リビングエアコンの<br>設置されている部屋が<br>低温状態です。";
			title = "エアコン低温通知（10℃）：リビングエアコン";
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
// CHG-ED #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
	    	break;
		case MENU_ID_MENU18:
			// 「エアコン消し忘れ」:CS_turnoff
			// PUSH通知サービス種別
			serviceID = "CS_turnoff";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "リビングのエアコンが運転中のままです。";
			title = "消し忘れ通知：エアコンが運転中のままです。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-22
				jsonObj.put("byMenu", true);
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-22
				jsB.notifyDidExitRegion(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
			break;
		case MENU_ID_MENU19:
			// 「快適帰宅」:CS_turnon
			// PUSH通知サービス種別
			serviceID = "CS_turnon";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
			message = "自宅に近づきました。リビングのエアコンを運転しますか？";
			title = "快適帰宅お知らせ：自宅に近づきました。";
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsB.notifyDidExitRegion(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			ret = true;
			break;
		case MENU_ID_MENU20:
			// 「PCPF取得エラー通知」:CS_dereference
			// PUSH通知サービス種別
			serviceID = "CS_dereference";
			// 機器ＩＤ
			applianceID = "CS-FAKE-W+1234543307";
			// ポップアップで表示するメッセージ
// CHG-ST #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
			message = "my家電名称<br>からの情報を取得できませんでした。";
			title = "エアコンデータ取得エラー：my家電名称";
// CHG-ED #24537:【PUSH通知】文言確定に伴う対応 PSDCD肖 2015-12-14
			try {
				JSONObject jsonObj = new JSONObject();
				jsonObj.put("service_id", serviceID);
				jsonObj.put("title", title);
				jsonObj.put("message", message);
				jsonObj.put("appliance_id", applianceID);
				jsB.showLocalNotificationByMenu(jsonObj.toString());
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}
			
			ret = true;
			break;
// ADD-ST #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
		case MENU_ID_MENU22:
			jsB.setPreference(THRESHOLD_KEY, "1");
			ret = true;
			break;
		case MENU_ID_MENU23:
			jsB.setPreference(THRESHOLD_KEY, "10");
			ret = true;
			break;
		case MENU_ID_MENU24:
			jsB.setPreference(THRESHOLD_KEY, "60");
			ret = true;
			break;
// ADD-ED #24315:【PUSH通知＠海外連携】閾値超えチェック周期の変更機能追加 PSDCD肖 2015-11-16
		}
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
        return ret;
    }
 // 開発時用RELOAD/EXITメニュー実装 add end

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
		if (getParam("SNS_LIBRARY_LOAD").equals("true")) {
			// ライブラリのロードが成功している場合
        if (SnsUtils.loadParam(this, SnsParams.FB_USERID) == null) {
            menu.findItem(MENU_ID_MENU4).setChecked(false);
        } else {
            menu.findItem(MENU_ID_MENU4).setChecked(true);
        }
        if (SnsUtils.loadParam(this, SnsParams.TW_USERID) == null) {
            menu.findItem(MENU_ID_MENU5).setChecked(false);
        } else {
            menu.findItem(MENU_ID_MENU5).setChecked(true);
        }
		}
// ADD-START TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
		if (ExternalServiceUtil.getApServerHttpsPort() == ExternalServiceUtil.AP_STG1_HTTPS_PORT) {		//DEL@PROD
			menu.findItem(MENU_ID_USE_AP_STG1).setChecked(true);										//DEL@PROD
		} else {																						//DEL@PROD
			menu.findItem(MENU_ID_USE_AP_STG2).setChecked(true);										//DEL@PROD
		}																								//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
// CHG-ST #23232:【使い方ガイド】STG1へのプロト開発 PSDCD肖　2015-09-08
		if (ExternalServiceUtil.getAp2ServerHttpsPort() == ExternalServiceUtil.AP2_STG1_HTTPS_PORT) {	//DEL@PROD
			menu.findItem(MENU_ID_USE_AP2_STG1).setChecked(true);										//DEL@PROD
		} else {																						//DEL@PROD
			menu.findItem(MENU_ID_USE_AP2_STG2).setChecked(true);										//DEL@PROD
		}																								//DEL@PROD
// CHG-ED #23232:【使い方ガイド】STG1へのプロト開発 PSDCD肖　2015-09-08
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
// ADD-END  TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
		return true;
    }

    @Override
	protected void onNewIntent(Intent intent) {

		super.onNewIntent(intent);
		Log.d("MyApplication", "StartApp#onNewIntent()");

        int flags = intent.getFlags();
        boolean isFromHistory = false;
        if ((flags & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) {
            // 起動履歴から起動した場合
            isFromHistory = true;
        }

// 2012/02/13 URLスキーム暫定対応 add start
		String action = intent.getAction();
        Log.d("MyApplication", "FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY@onNewIntent="+isFromHistory);
        Log.d("MyApplication", "CATEGORIES@onNewIntent="+intent.getCategories());
        Log.d("MyApplication", "ACTION@onNewIntent="+action);

//ADD-ST:TF-#10954 2013/07/26 (PSNRD)
        Log.d("MyApplication", "flags=0x" + Integer.toHexString(flags));
        ComponentName componentName = getCallingActivity();
        if (componentName != null) {
            Log.d("MyApplication", "getCallingActivity().getPackageName(): " + componentName.getPackageName());
            Log.d("MyApplication", "getCallingActivity().getClassName(): " + componentName.getClassName());
            Log.d("MyApplication", "getCallingActivity().getShortClassName(): " + componentName.getShortClassName());
        }
        Log.d("MyApplication", "getCallingPackage(): " + getCallingPackage());
        Log.d("MyApplication", "getScheme(): " + intent.getScheme());
        Log.d("MyApplication", "getType(): " + intent.getType());
//ADD-ED:TF-#10954 2013/07/26 (PSNRD)

		//if (Intent.ACTION_VIEW.equals(action)) {
		if ((isFromHistory==false) && Intent.ACTION_VIEW.equals(action)) {
			Log.d("Dbg", "onNewIntent() root-1");
			// 起動履歴ではなく、ブラウザから起動された場合
			//actionには「android.intent.action.VIEW」が設定される
        	Uri uri = intent.getData();
            // uriには、ブラウザで設定した「sample://arg1=123&arg2=abc」が設定されます
            Log.d("MyApplication", "Kicked from Browser: uri = [" + uri.toString() + "]");
            // 飛び先IDの文字列取得
// MOD-ST [欠陥管理 TF-#10401]【SNS連携】Panasonic Cooking「牛肉100%ハンバーグ」のレシピの投稿からお気に入り登録すると、「G-11292-30104」が発生する
//　MOD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
            // 飛び先もextraデータで指定できるよう拡張する。
            //String gotoId = uri.getHost();
            //String gotoId = uri.getEncodedAuthority();
            String gotoId;
            if (intent.hasExtra("goto")) {
            	// extraDataで指定されている場合はそちらを優先
            	try {
					gotoId = java.net.URLEncoder.encode(intent.getStringExtra("goto"), "UTF-8");
					Log.d("MyApplication", "set from extraData. (goto)");
				} catch (UnsupportedEncodingException e) {
					Log.d("MyApplication", "URL encode failed. (goto)");
					e.printStackTrace();
					gotoId = "";
				}
            } else {
				Log.d("MyApplication", "not found in extraData. (goto)");
            	gotoId = uri.getEncodedAuthority();
            	// Chromeからのintent起動の場合、gotoIdの末尾に":"が付与されるため除去する。
//CHG-ST [欠陥管理 TF-#20721] PSAのお気に入り一覧から「HEMS」を選択し、HEMS画面をブラウザで表示後、「戻る」押下するとPSAが落ちる。
            	if ((gotoId.length() > 0) && (gotoId.indexOf(":") == (gotoId.length() - 1))) {
//CHG-ED [欠陥管理 TF-#20721] PSAのお気に入り一覧から「HEMS」を選択し、HEMS画面をブラウザで表示後、「戻る」押下するとPSAが落ちる。
            		Log.d("MyApplication", "chop \":\" from gotoId");
            		gotoId = gotoId.substring(0, gotoId.length() - 1);
            	}
            }
//　MOD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
// MOD-ED [欠陥管理 TF-#10401]【SNS連携】Panasonic Cooking「牛肉100%ハンバーグ」のレシピの投稿からお気に入り登録すると、「G-11292-30104」が発生する
//3rd party連携 add start
// MOD-ST [欠陥管理 TF-#17349]【携帯プリ】 新レシピ タッチ機能の開発　キッチンポケットからの起動時、PSAでパラメータを取得できない
            //String query = uri.getQuery();
            String query;
            if("EXTTCH0010".equals(gotoId)){
                // キッチンポケットの場合
                query = uri.getEncodedQuery();
//　MOD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
                // キッチンポケット連携のパラメータがextraDataに指定されていたら追加 (欠陥管理 TF-#17946)
                if (intent.hasExtra("recipe_name")) {
                	try {
						query = "recipe_name=" + java.net.URLEncoder.encode(intent.getStringExtra("recipe_name"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (recipe_name)");
                	} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode failed. (recipe_name)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (recipe_name)");
                }
                if (intent.hasExtra("recipedata")) {
                	try {
						query = "recipedata=" + java.net.URLEncoder.encode(intent.getStringExtra("recipedata"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (recipedata)");
					} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode faild. (recipedata)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (recipedata)");
                }
//　MOD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
// ADD-ST #12713:【事前検討】15夏おやすみナビ対応 PSDCD肖 2015-02-06
            } else if("ACMEST001".equals(gotoId)){
                // おやすみナビからどこでもリモコン画面に遷移の場合
                query = uri.getEncodedQuery();
                if (intent.hasExtra("appliance_id")) {
                	try {
						query = "appliance_id=" + java.net.URLEncoder.encode(intent.getStringExtra("appliance_id"), "UTF-8") + "&" + query;
						Log.d("MyApplication", "set from extraData. (appliance_id)");
                	} catch (UnsupportedEncodingException e) {
						Log.d("MyApplication", "URL encode failed. (appliance_id)");
						e.printStackTrace();
					}
                } else {
					Log.d("MyApplication", "not found in extraData. (appliance_id)");
                }
// ADD-ED #12713:【事前検討】15夏おやすみナビ対応 PSDCD肖 2015-02-06
            }else {
// CHG-ED #12713:【事前検討】15夏おやすみナビ対応 PSDCD肖 2015-02-06
                // TODO [仕様変更管理 TF-#18092] 他のアプリ連携でのextraDataの扱いは別途検討
                query = uri.getQuery();
            }
// MOD-ED [欠陥管理 TF-#17349]【携帯プリ】 新レシピ タッチ機能の開発　キッチンポケットからの起動時、PSAでパラメータを取得できない
//　ADD-ST [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
            if(intent.hasExtra("fedauth")) {
            	query = "fedauth=" + intent.getStringExtra("fedauth") + "&" + query;
				Log.d("MyApplication", "set from extraData. (fedauth)");
            } else {
				Log.d("MyApplication", "not found in extraData. (fedauth)");
            }
//　ADD-ED [仕様変更管理 TF-#18092] SSOのインテント起動時にextraデータにfedauthを格納する(脆弱性検証指摘）
//3rd party連携 add end
            Log.d("MyApplication", "Kicked from Browser: gotoId = [" + gotoId + "]");
//3rd party連携 add start
            Log.d("MyApplication", "Kicked from Browser: query = [" + query + "]");
//3rd party連携 add end
// ADD-ST [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
//             // 飛び先画面を表示
//             String loginUrl = GEMINI_LOGIN_URL + gotoId + "&_=" + Math.random();
//             Log.d("MyApplication", "GEMINI_LOGIN_URL = " + loginUrl);
            String loginUrl;
            Pattern pattern = Pattern.compile("^SCURL.*");
            Matcher matcher = pattern.matcher(gotoId);
            boolean isScurl= matcher.matches();

            pattern = Pattern.compile("^SCUXPORTAL.*");
            matcher = pattern.matcher(gotoId);
            boolean isScuxportal= matcher.matches();
            Log.d("MyApplication", "isScurl = " + isScurl);
            Log.d("MyApplication", "isScuxportal = " + isScuxportal);
            if( isScurl || isScuxportal ){
                loginUrl = GEMINI_SCURL_URL + gotoId + "&_=" + Math.random();
                Log.d("MyApplication", "GEMINI_SCURL_URL = " + loginUrl);
//3rd party連携 change start
            } else if ((query != null) && (!(query.equals("")))) {
                loginUrl = GEMINI_LOGIN_URL + gotoId + "&" + query + "&_=" + Math.random();
                Log.d("MyApplication", "loginUrl = " + loginUrl);
//3rd party連携 change end
            }else{
                loginUrl = GEMINI_LOGIN_URL + gotoId + "&_=" + Math.random();
                Log.d("MyApplication", "GEMINI_LOGIN_URL = " + loginUrl);
            }
// ADD-ED [作業管理 TF-#8150] 【UX改善】HTML/JS対応 (STEP2)
            String lastUrl = wv.getUrl();
            String uxPortalQueries = "goto=SCUXPORTAL&usecase_id=SYS_COM_UXPORTAL_01_001";
            Log.d("Dbg", "onNewIntent() root-1 lastUrl "+lastUrl);
            if((gotoId != null) && (gotoId.equals("") == false)) {
                // goto指定(画面指定、ショートカット)の場合
                Log.d("Dbg", "onNewIntent() root-1 do wv.loadUrl "+loginUrl);
	            wv.loadUrl(loginUrl);
//CHG-ST:TF-#11785 2013/09/12 (PSNRD) "lastUrl"のNULLチェック追加
            } else if ( lastUrl != null && lastUrl.contains(uxPortalQueries)) {
//CHG-ED:TF-#11785 2013/09/12 (PSNRD)
                // goto指定が無く、UXポータルお気に入り画面を表示中(ユースケース：UXポータルお気に入り)の場合
                Log.d("Dbg", "onNewIntent() root-1 do wv.reload "+lastUrl);
                wv.reload();
            }
// ADD-ST 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
		} else if (action.equals(ACTION_PUSH_MESSAGE_GCM)) {
			 // PUSH通知サービス種別 
			 String serviceID = intent.getStringExtra(PUSH_RECEIVE_SERVICE_ID);
			 // 機器ＩＤ
			 String applianceID = intent.getStringExtra(PUSH_RECEIVE_APPLIANCE_ID);
			 // ポップアップ表示用メッセージ
			 String alertMsg = intent.getStringExtra(PUSH_RECEIVE_MESSAGE);
			 loadPushPopUrl(serviceID, applianceID, alertMsg);
// ADD-ED 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
		} else {
// 2012/02/13 URLスキーム暫定対応 add end
			// 通常起動の場合
			// 2012/09/12 #5017 アプリ同時起動対応 delete start
			// FeliCa Polling結果通知受信
			//final int resultCode = intent.getIntExtra(
			//		nfcWrapper.KEY_FELICA_POLLING_RESULT,
			//		nfcWrapper.RES_SUCCESS);
			//
			//Log.d("MyApplication", "--- polling result=" + resultCode);
			// 2012/09/12 #5017 アプリ同時起動対応 delete end

// ADD-ST [欠陥管理 TF-#9177] 【UX改善】PSNRD 2013-04-08
            /*
			// お気に入り画面でホームボタンを押下し、PSAアイコンをタップすると白画面になる件の対応
			// Resume時にStartAppが起こされるケースがあるので、その場合はSC Activityを起動しなおす。
			if (Intent.ACTION_MAIN.equals(action) && mScManager.isShortcutsUiEnabled()) {
				Set<String> categories = intent.getCategories();
				String uxPortalQueries = "goto=SCUXPORTAL&usecase_id=SYS_COM_UXPORTAL_01_001";
				String lastUrl = wv.getUrl();
				Log.d("MyApplication", "last url: " + lastUrl);
				if (categories.contains(Intent.CATEGORY_LAUNCHER) && lastUrl.contains(uxPortalQueries)) {
					wv.reload();
					return;
				}
			}
            */
			// 起動履歴かPSAアイコンタップで起動した場合
            Set<String> categories = intent.getCategories();
//CHG-ST:TF-#10241 2013/07/04 (山形)
		    if( (isFromHistory==true) || (Intent.ACTION_MAIN.equals(action) && ((categories != null) && (categories.contains(Intent.CATEGORY_LAUNCHER))))
//CHG-ED:TF-#10241 2013/07/04 (山形)
//ADD-ST:TF-#10954 2013/07/26 (PSNRD)
		    		// Google Play(GB版)の「開く」からの起動の場合
		    		|| (Intent.ACTION_MAIN.equals(action) && flags == (Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT))) {
//ADD-ED:TF-#10954 2013/07/26 (PSNRD)
				String uxPortalQueries = "goto=SCUXPORTAL&usecase_id=SYS_COM_UXPORTAL_01_001";
				String lastUrl = wv.getUrl();
				Log.d("MyApplication", "last url: " + lastUrl);
//CHG-ST:TF-#11785 2013/09/12 (PSNRD) "lastUrl"のNULLチェック追加
				if (lastUrl != null && lastUrl.contains(uxPortalQueries)) {
//CHG-ED:TF-#11785 2013/09/12 (PSNRD)
			        // 現画面がお気に入り画面の場合は、画面を復元する
					wv.reload();
					return;
				}
            }
// ADD-ED [欠陥管理 TF-#9177] 【UX改善】PSNRD 2013-04-08

			// タッチ画面表示中にタグ取得を有効とする
			if (isEnableNfc == DISABLE_NFC) {
				Log.d("MyApplication", "isEnableNfc == DISABLE_NFC");
				return;
			}

			// 割り込み対応（割り込み⇒復帰でOnNewIntentが呼び出される）
			int flg = intent.getFlags();
			Log.d("MyApplication", "OnIntent  flg = " + flg);
			if (!isNfcExist) {  // Felica
				Log.d("MyApplication", "type:Felica OnIntent return");
				return;
//			} else {   // NFC
//				// ポーリング成功した場合は、flag=0x30000000
//				if (intent.getFlags() != 0x30000000 ){
//					Log.d("MyApplication", "type:NFC OnIntent not Polling Completed ");
//					return;
//				}
			}

			// Geminiシステムコードを有効とする
			if(!(checkNfcTag(intent))) {
				Log.d("MyApplication", "(checkNfcTag(intent)) == false");
				return;
			}

			// リードライト処理スレッド化
	    	startReadWriteNfcThread();

		}
// 2012/02/13 URLスキーム暫定対応 add end
	}

	/**
	 * ポーリングからのリトライ開始API(Helper Function)
	 */
	private void retryTouchFromPolling() {
    	Log.d("MyApplication", "StartApp#retryTouchFromPolling()");
		nfcW.enableNfc(this, true);
	}

	// 2012/08/02 #4177対応 add start
	/**
	 * タッチ状態取得からのリトライ開始API(Helper Function)
	 */
	private void touchFromCheckTouchStat() {
    	Log.d("MyApplication", "StartApp#touchFromCheckTouchStat()");
		nfcW.enableNfc(this, false);
	}
	// 2012/08/02 #4177対応 add end

	/**
	 * NFC / FeliCa リードライト処理スレッド起動
	 * リードライト処理スレッド化
	 */
    protected void startReadWriteNfcThread() {

    	Log.d("MyApplication", "StartApp#startReadWriteNfcThread()");

    	new Thread( new Runnable() {
			@Override
			public void run() {
				boolean result = readWriteNfc();
				if ( result == true ) {
					if (mLastTouchResult == nfcWrapper.RES_ERROR_TOUCH_RW_TIMEOUT) {
						// タッチタイムアウト発生：リトライ処理

						// プログレス表示を消す
						jsB.notifyNfcRetry();

						// 現在利用中のNFC（or Felica）を判定する
						if (nfcW.mNfcPreferred) {	// 2012/08/21 #4487対応 modified
							Log.d("MyApplication", "StartApp#startReadWriteNfcThread : mNfcPreferred == true");
							/* NFCの場合：ここで即座にリトライは出来ないため、リトライ用のフラグだけONし
							 * setTagInfoForNfcでリトライを設定。
							 */
							synchronized (mTouchRwTimeoutOccuredForNfc) {
								mTouchRwTimeoutOccuredForNfc = true;
							}
							return; // 終了通知は行わずThread終了。
						} else {
							Log.d("MyApplication", "StartApp#startReadWriteNfcThread : mNfcPreferred == false");
							// FeliCaの場合：リトライ時はActivityがフォアグラウンドにいる場合のみポーリング再開
							if (hasWindowFocus()) {
								// 2012/09/10 #5106対応 add start
								synchronized (mTouchRwTimeoutOccuredForNfc) {
									mTouchRwTimeoutOccuredForNfc = true;
								}
								// 2012/09/10 #5106対応 add end
								retryTouchFromPolling();
								return; // 終了通知は行わずThread終了。
							}
						}
					}

					// NFCタグ取得有効フラグを解除する
					disableNfc();
					handler.post( new Runnable() {
						@Override
						public void run() {
							notifyNfcFinish();
						}
					});
				}
			}
		}).start();
   }

    /**
     * NFC / FeliCa リードライト処理
     * リードライト処理スレッド化
     */
    protected boolean readWriteNfc() {

    	Log.d("MyApplication", "StartApp#readWriteNfc()");

    	boolean result = true;

    	if (isEnableNfc == ENABLE_NFC_PRELOGIN) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_PRELOGIN");
			nfcW.setProductCodeForControl(null);
			// ログイン前
			mLastTouchResult = nfcW.readApplianceCommonData();
			// 完了通知
//			notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_TIME) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_TIME");
			nfcW.setProductCodeForControl(null);
			// 時刻設定
			mLastTouchResult = nfcW.writeCurrentTime(mUserIdCode, mDesignatedCategory);
			// 完了通知
//			notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_REPAIR) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_REPAIR");
			nfcW.setProductCodeForControl(null);
			// 計測データ回復
			mLastTouchResult = nfcW.readMeasurementDataForRepairMode(mUserIdCode, mDesignatedCategory);
			// 完了通知
//			notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_USERID) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_USERID");
			nfcW.setProductCodeForControl(null);
			// ユーザ識別コード
			mLastTouchResult = nfcW.writeUserIdentificationCode();
			// 完了通知
//			notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_GETUSERINFO) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_GETUSERINFO");
			nfcW.setProductCodeForControl(null);
			// ユーザ情報取得
			int readSize = INFOSIZE_CALORIEMETER;
			if (mDesignatedCategory == CATEGORY_COMPOSITIONMETER) {
		    	Log.d("MyApplication", "StartApp#readWriteNfc : mDesignatedCategory == CATEGORY_COMPOSITIONMETER");
				// 体組成計の場合、４名分の情報を一括で読み込む
				readSize = INFOSIZE_COMPOSITIONMETER;
			}
			mLastTouchResult = nfcW.getUserInfo(mDesignatedCategory, readSize);
			// 完了通知
//		    notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_SETUSERINFO) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_SETUSERINFO");
			nfcW.setProductCodeForControl(null);
			// ユーザ情報設定
			int writeAddr = INFOADDR_COMPOSITIONMETER1;
			if (mDesignatedCategory == CATEGORY_COMPOSITIONMETER) {
		    	Log.d("MyApplication", "StartApp#readWriteNfc : mDesignatedCategory == CATEGORY_COMPOSITIONMETER");
				// 体組成計の場合、選択されたユーザメモリへ書き込む
				writeAddr = mUserMemory;
			}
			mLastTouchResult = nfcW.writeUserInfo(mDesignatedCategory, writeAddr);
			// 完了通知
//		    notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_DELUSERINFO) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_DELUSERINFO");
			nfcW.setProductCodeForControl(null);
			// ユーザ情報削除
			mLastTouchResult = nfcW.deleteUserInfo(mUserIdCode, mDesignatedCategory);
			// 完了通知
//		    notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_RDMEASURE) {
	    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_RDMEASURE");
			nfcW.setProductCodeForControl(null);
			// 計測データ読出
			mLastTouchResult = nfcW.readUnreadMeasurementData(mUserIdCode, mDesignatedCategory);
			// 完了通知
//		    notifyNfcFinish();
		}else if (isEnableNfc == ENABLE_NFC_REGISTER) {
			Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_REGISTER");
			nfcW.setProductCodeForControl(null);
			// My家電登録（時刻補正あり）
			mLastTouchResult = nfcW.rwForApplianceRegistration();
		} else {
			// 2012.01.17 modified start
			// タッチ時にアプリが強制終了する不具合を修正。
//			// NFCデータ読み込み
//			if (nfcW.readNfcData(mUserIdCode) == nfcWrapper.RES_SUCCESS) {
				if (isEnableNfc == ENABLE_NFC_RD) {
			    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_RD");
					nfcW.setProductCodeForControl(null);
					// NFCデータの読み出し
					mLastTouchResult = nfcW.readNfcData(mUserIdCode);
					// 完了通知
//					notifyNfcFinish();

				} else if (isEnableNfc == ENABLE_NFC_RW) {
			    	Log.d("MyApplication", "StartApp#readWriteNfc : isEnableNfc == ENABLE_NFC_RW");
					// NFCデータの書き込み
			    	mLastTouchResult = nfcW.writeNfcData();
					// 完了通知
//					notifyNfcFinish();
				} else {
					// 修正前の処理と同じにしておく(notifyNfcFinishを呼ばない)
			    	Log.e("MyApplication", "StartApp#readWriteNfc : Unknown isEnableNfc !!");
					result = false;
				}
//			} else {
//				// 異常系の処理記載
//			}
		}

    	return result;
    }

	@Override
	protected void onResume() {
		super.onResume();
		Log.d("MyApplication", "onResume()");

		// 直前のシステム音量を保存して消去
		//DEL-ST 欠陥管理#8722
		//tapSoundVolume = myAudioManager.getStreamVolume(AudioManager.STREAM_SYSTEM);
		//myAudioManager.setStreamVolume(AudioManager.STREAM_SYSTEM, 0, 0);
		//Log.d("MyApplication", "tap volume: "+tapSoundVolume+" => 0");
		//DEL-ED 欠陥管理#8722

		// Cookieの自動同期を開始
		cookieSyncManager.startSync();
    	Log.d("MyApplication", "cookieSyncManager.startSync");
        Log.d("MyApplication", "cookie("+AUTH_HOST+"): "+cookieManager.getCookie("https://"+AUTH_HOST));

		/* 初回起動時、または、onPauseから指定時間以上経過後のResumeの場合は
		 * コンテンツを再取得してバージョンチェックする */

// MOD-ST [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある
        if( requiredVersionFile ) {
            // VERSION_FILEファイルの取得
//MOD-ST PAD-#11726
            VersionCheck.getInstance().doGetByHttpClient(VERSION_FILE);
//MOD-EN PAD-#11726
            requiredVersionFile = false;
        }
// MOD-ED [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある

		isPoolingPaused = false;

        if (!isNfcExist) {
    		if (mTouchStat != TOUCH_OK && mTouchStat != TOUCH_NO_CHECK) {    	// NFC あるいは Felicaが利用可能かチェック
    			Log.d("MyApplication", "checkNfcOrFelicaAvailability()");
    			nfcWrapper.checkNfcOrFelicaAvailability(this);
    		}
			// Felica
			if (isEnableNfc != DISABLE_NFC) {
				if ( Util.checkNetworkState(this) == 0) {
					disableNfc();
					closeProgressDialog();
					loadErrUrl(
							SYSTEM_ERR_CODE_G_11292_30001,
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("ERR_MESSAGE"),
							ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("BTN_NAME")
						);
				} else {
					//　Felica接続処理
					Log.d("MyApplication", "call enableNfc()");
					// 2012/09/10 #5106対応 modified start
					synchronized (mTouchRwTimeoutOccuredForNfc) {
						if (mTouchRwTimeoutOccuredForNfc) {
							retryTouchFromPolling();
						} else {
							nfcW.enableNfc(this, false);
						}
					}
					// 2012/09/10 #5106対応 modified end
				}
			}
		} else {
			// NFC
	    	// NFC設定ON/OFFの判定（Suspend状態で設定ONされる場合を考慮）
			isNfcAvailable = Util.checkNfcAvailable(this.getApplicationContext());
			if (isNfcAvailable) {
				if ( isEnableNfc != DISABLE_NFC && Util.checkNetworkState(this) == 0) {
					closeProgressDialog();
					loadErrUrl(
						SYSTEM_ERR_CODE_G_11292_30001,
						ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("ERR_MESSAGE"),
						ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30001).get("BTN_NAME")
					);
				}
				// NFC受信待ち状態設定
				Log.d("MyApplication", "call enableNfc()");
				nfcW.enableNfc(this, false);
				resumeNfcPollingTimer();
			} else {
				Log.d("MyApplication", "NFC Setting OFF()");
				if ( isEnableNfc != DISABLE_NFC ){
					closeProgressDialog();
			    	// 2012/08/21 #4487対応 modified start
			    	// Felicaが利用可能かチェック
	    			mCheckTouchStat = true;
	    			nfcWrapper.checkNfcOrFelicaAvailability(this);
			    	// 2012/08/21 #4487対応 modified end
				}
			}
		}

        if( onPauseFullWakeLockFlg ) {
            // 自動消灯をOFF
            sleepScreenOff();
            onPauseFullWakeLockFlg = false;
        }

        // カメラ撮影の一時ファイルが残っていた場合は削除する
		File file = new File(Environment.getExternalStorageDirectory(), "gemini000.tmp");
		if (file != null && file.exists()) {
			file.delete();
		}

		// 仕様変更0295対応
        // 洗濯機　予約ありのタッチ画面でonResume時に予約設定画面に遷移（長坂）
        // onResume()をJSへ通知
		new Thread(new Runnable() {
			public void run() {
				jsB.notifyOnResume();
			}
		}).start();
	}

	@Override
	protected void onPause() {
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONPAUSE);

		super.onPause();
		Log.d("MyApplication", "onPause()");

		// システム音量を復帰
		//DEL-ST 欠陥管理#8722
		//myAudioManager.setStreamVolume(AudioManager.STREAM_SYSTEM, tapSoundVolume, 0);
		//Log.d("MyApplication", "tap volume: 0 => "+tapSoundVolume);
		//DEL-ED 欠陥管理#8722

//DEL-ST PAD-#11726
//DEL-EN PAD-#11726
//ADD-ST PAD-#11726
		// バージョンチェック用のアプリ起動時判定フラグをOFFする
		isAppStartUp = false;
		Log.d("MyApplication", "onPause() isAppStartUp = false");
//ADD-EN PAD-#11726

		// エアコン宅内制御時に、onPause()をJSへ通知
		new Thread(new Runnable() {
			public void run() {
				jsB.notifyPutCommandResult();
			}
		}).start();

		// プログレスダイアログ クローズ
//		closeProgressDialog();

		// cookieを保存
		cookieSyncManager.sync();
		// cookieを同期を停止
		cookieSyncManager.stopSync();
		Log.d("MyApplication", "cookie("+AUTH_HOST+"): "+cookieManager.getCookie("https://"+AUTH_HOST));

    	isPoolingPaused = true;
		// 現在利用中のNFC（or Felica）を判定する（NFC/Felica非搭載の場合を考慮）
		if (!nfcW.mNfcPreferred && mTouchStat == TOUCH_OK) {	// 2012/08/21 #4487対応 modified
			Log.d("MyApplication", "StartApp#onPause : mNfcPreferred == false");
			//　Felica切断処理
			Log.d("MyApplication", "call disableFelica()");
//			nfcW.disableFelica(this);
			disableNfcForPause();
		} else if (isNfcAvailable) {
			Log.d("MyApplication", "StartApp#onPause : mNfcPreferred == true");
			// NFC受信終了処理
			Log.d("MyApplication", "call disableNfc()");
			nfcW.disableNfc(this);
			pauseNfcPollingTimer();
		} else {
			Log.d("MyApplication", "StartApp#onPause : mNfcPreferred == true");
			// NFC設定OFFのため、何もしない
			Log.d("MyApplication", "NFC Setting OFF()");
		}

        // 自動消灯をON
        onPauseFullWakeLockFlg = fullWakeLockFlg;
        sleepScreenOn();

        // アプリログの一時退避
        // TODO onPause()の処理を圧迫する可能性がある為、2012/5/31時点では対応を見送る
        //Log.backupAppLog();
	}

	@Override
	protected void onDestroy() {
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONDESTROY);

		super.onDestroy();
		Log.d("MyApplication", "onDestroy()");

		// ページ遷移中に終了した場合、タイマーをキャンセル
		if (mRespTimer != null) {
			mRespTimer.cancel();
			mRespTimer = null;
		}

		// ADD-ST TF-#11041 【3rd Party連携】adidas連携：携帯アプリ実装
		// ダイアログが残ったままの場合、消去する。
		if(mWaitDialog != null){
			mWaitDialog.dismiss();
			mWaitDialog = null;
		}
		// ADD-ED TF-#11041 【3rd Party連携】adidas連携：携帯アプリ実装

        // 効果音のクリア
		unLoadSound();

		wv.destroy();
		// 終了時に例外が出てたのを対応
		unregisterReceiver(mReceiver);
		unregisterReceiver(nwReceiver);
        // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-26
        unregisterReceiver(dlReceiver);
        // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-26

		// ADD-START TF-#11088 Google Analyticsを利用したエラートラッキング対応 
		// GAログ ディスパッチ処理
		if (getParam("SNS_LIBRARY_LOAD").equals("true")) {
			GoogleAnalyticsManager.doDispatch(this.getApplicationContext());
		}
		// ADD-END   TF-#11088 Google Analyticsを利用したエラートラッキング対応 

//		// [暫定]自プロセスを終了させる
//		android.os.Process.killProcess(android.os.Process.myPid());
        // アプリログの一時退避
        Log.backupAppLog();
	}

	/**
	 * Activity処理結果通知。<br>
	 * @param  requestCode : 処理結果
	 * @param  resultCode : リクエストコード
	 * @param  data : 処理されたデータ
	 * @return none
	 */
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		Log.i("MyApplication", "onActivityResult() requestCode=" +
				requestCode + " resultCode" + resultCode + " data" + data);
		Log.d("MyApplication", "onActivityResult() resultCode=" + resultCode);

		if (requestCode == REQUEST_GALLERY || requestCode == REQUEST_CAMERA) {
			if (resultCode != RESULT_OK){
			    Log.d("MyApplication", "onActivityResult() resultCode != RESULT_OK");
			    // カメラの場合、一時ファイルを削除する
			    if (requestCode == REQUEST_CAMERA) {
		    		File file = new File(Environment.getExternalStorageDirectory(), "gemini000.tmp");
		    		if (file != null && file.exists()) {
						file.delete();
		    		}
			    }
	            return;
	        }

			ContentResolver conReslv = getContentResolver();
            // 画像URIを取得
	        if (requestCode == REQUEST_GALLERY) {
				// ギャラリーの場合
				Log.d("MyApplication", "requestCode == REQUEST_GALLERY");
	            mImageUri = data.getData();
	        } else {
				// カメラの場合：撮影した画像のURIを取得
				Log.d("MyApplication", "requestCode == REQUEST_CAMERA");
	            mImageUri = null;
	    		File file = new File(Environment.getExternalStorageDirectory(), "gemini000.tmp");
	    		if (file != null && file.exists()) {
					// 一時ファイルからURIを解析し、画像ファイル取得
// DEL-ST: TF-#4669 2012/08/08 (山形)
//					Uri uri = null;
//					String imageName = DateFormat.format("yyyy-MM-dd_kk.mm.ss", System.currentTimeMillis()).toString();
//					try {
//						uri = Uri.parse(android.provider.MediaStore.Images.Media.insertImage(
//								conReslv, file.getAbsolutePath(), imageName, null));
// DEL-ED: TF-#4669 2012/08/08 (山形)
// ADD-ST: TF-#4669 2012/08/08 (山形)
						mImageUri = Uri.fromFile(file);
// ADD-ED: TF-#4669 2012/08/08 (山形)
// DEL-ST: TF-#4669 2012/08/08 (山形)
//					} catch (FileNotFoundException e) {
//						e.printStackTrace();
//					}
//					// 目的のURI取得したので一時ファイルは削除
//					file.delete();
//					if (uri != null) {
//						// 取り出す情報にMediaFileを指定
//						String[] columns = { MediaStore.Images.Media.DATA };
//						Cursor c = conReslv.query(uri, columns , null, null, null);
//						c.moveToFirst();
//						mImageUri = Uri.fromFile(new File(c.getString(0)));
//						c.close();
//		    		}
// DEL-ED: TF-#4669 2012/08/08 (山形)
	    		}
	        }

            Log.d("MyApplication","mImageUri="+mImageUri);
            if (mImageUri != null) {
                try {
                    /*
                    // ビットマップ画像を取得
                    Bitmap bitmap = MediaStore.Images.Media.getBitmap(conReslv, mImageUri);

    	            //ファイルパスを取得したい場合は下記のようにContentResolverを活用する
    	            //ContentResolver経由でファイルパスを取得
    	            ContentResolver cr = getContentResolver();
    	            String[] columns = {MediaStore.Images.Media.DATA };
    	            Cursor c = cr.query(mImageUri, columns, null, null, null);

    	            c.moveToFirst();
    	            File picture = new File(c.getString(0));

    		        // Bitmap のサイズの取得
    		        int width = bitmap.getWidth();
    		        int height = bitmap.getHeight();
    				Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY before width=" + width);	//2560
    				Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY before　height=" + height);//1920

    	            // VGAサイズにリサイズする
    	            bitmap = Util.getResizeBitmap(picture, VGA_WIDTH, VGA_HEIGHT);

    		        // Bitmap のサイズの取得
    		        width = bitmap.getWidth();
    		        height = bitmap.getHeight();
    				Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after width=" + width);	//640
    				Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after height=" + height);	//480
                    */

                    // ビットマップ画像のサイズを取得
                    InputStream is = conReslv.openInputStream(mImageUri);
                    BitmapFactory.Options opts = new BitmapFactory.Options();
                    opts.inJustDecodeBounds = true; //画像全体は取り込まない。
                    Bitmap tmpBitmap = null;
                    try {
                    	tmpBitmap = BitmapFactory.decodeStream(is, null, opts);
                    } catch (OutOfMemoryError e) {
                    	//TODO OutOfMemoryが再発した場合のデバッグ用。どこかのタイミングで消す？
                    	Log.e("MyApplication", "OutOfMemoryError: " + e);
                        e.printStackTrace();
                        String message = "** Out Of Memory **";
                        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                        System.gc();
                        return;
                    } catch (Exception e) {
                    	Log.e("MyApplication", "Exception: " + e);
                        e.printStackTrace();
                        String message = "写真の取得に失敗しました";
                        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                    }
                    is.close();

                    //サイズ設定
                    int newWidth = VGA_WIDTH;
                    int newHeight = VGA_HEIGHT;
                    //int origWidth = bitmap.getWidth();
                    //int origHeight = bitmap.getHeight();
                    int origWidth = opts.outWidth;
                    int origHeight = opts.outHeight;

                    //VGAに近いサイズに縮小(メモリ削減)してdecodeStream実行
                    opts.inJustDecodeBounds = false;
                    opts.inSampleSize = Math.max((int)Math.floor(origWidth / newWidth), (int)Math.floor(origHeight / newHeight));
                    Log.d("MyApplication", "inSampleSize="+opts.inSampleSize);
                    is = conReslv.openInputStream(mImageUri);
                    try {
                    	tmpBitmap = BitmapFactory.decodeStream(is, null, opts);
                    } catch (OutOfMemoryError e) {
                    	//TODO OutOfMemoryが再発した場合のデバッグ用。どこかのタイミングで消す？
                    	Log.e("MyApplication", "OutOfMemoryError: " + e);
                        e.printStackTrace();
                        String message = "*** Out Of Memory ***";
                        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                        System.gc();
                        return;
                    } catch (Exception e) {
                    	Log.e("MyApplication", "Exception: " + e);
                        e.printStackTrace();
                        String message = "写真の取得に失敗しました";
                        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                    }
                    is.close();

                    // VGAサイズに再リサイズする
                    origWidth = tmpBitmap.getWidth();
                    origHeight = tmpBitmap.getHeight();
                    float scale = Util.getFitScale(newWidth, newHeight, origWidth, origHeight);
                    Matrix matrix = new Matrix();
                    matrix.postScale(scale, scale);
                    Bitmap bitmap = Bitmap.createBitmap(tmpBitmap, 0, 0, origWidth, origHeight, matrix, true);

                    // Bitmap のサイズの取得
                    int width = bitmap.getWidth();
                    int height = bitmap.getHeight();
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY origWidth=" + origWidth);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY origHeight=" + origHeight);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY newWidth=" + newWidth);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY newHeight=" + newHeight);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY scale=" + scale);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after width=" + width);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after height=" + height);

                    /*
                    // ビットマップ画像を取得
                    InputStream is = conReslv.openInputStream(mImageUri);
                    Bitmap bitmap = BitmapFactory.decodeStream(is);

                    //サイズ設定
                    int newWidth = VGA_WIDTH;
                    int newHeight = VGA_HEIGHT;
                    int origWidth = bitmap.getWidth();
                    int origHeight = bitmap.getHeight();

                    //表示利用域に合わせたサイズを計算
                    if (newWidth > 0 && newHeight <= 0) {
                        newHeight = (newWidth * origHeight) / origWidth;
                    }
                    else if (newWidth <= 0 && newHeight > 0) {
                        newWidth = (newHeight * origWidth) / origHeight;
                    }
                    else {
                        double newRatio = newWidth / (double)newHeight;
                        double origRatio = origWidth / (double)origHeight;

                        if (origRatio > newRatio) {
                            newHeight = (newWidth * origHeight) / origWidth;
                        } else if (origRatio < newRatio) {
                            newWidth = (newHeight * origWidth) / origHeight;
                        }
                    }
                    // Bitmap のサイズの取得
                    bitmap = Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true);

                    // Bitmap のサイズの取得
                    int width = bitmap.getWidth();
                    int height = bitmap.getHeight();
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY origWidth=" + origWidth);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY origHeight=" + origHeight);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY newWidth=" + newWidth);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY newHeight=" + newHeight);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY scale=" + scale);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after width=" + width);
                    Log.d("MyApplication", "onActivityResult() REQUEST_GALLERY after height=" + height);
                    */

                    // Bitmapデータの受け渡し確認用
                    // javascriptｆではバイト配列は扱えないため、Base64エンコードして渡す
                    // Bitmap→byte配列へ変換
					byte[] image = Util.changeBmpToData(bitmap, Bitmap.CompressFormat.JPEG, 100);
					jsB.mImageData = Base64.encodeToString(image, Base64.DEFAULT);

					jsB.notifyImageReady();
                } catch (Exception e) {
                	Log.e("MyApplication", "Exception: " + e);
                    e.printStackTrace();
                    // 写真取得に失敗した場合
                    String message = "写真を取得できませんでした";
                    Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                }
            }
	    }
// ADD-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
		else if (requestCode == REQUEST_CONTACTS) {
	        if (resultCode == Activity.RESULT_OK) {
	        	// 電話帳の場合
	            ContentResolver reContentResolverol = getContentResolver();
	            Uri contactData = data.getData();
	            
	            Cursor cursor = managedQuery(contactData, null, null, null, null);
	            cursor.moveToFirst();
	            	            
	            String contactId = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));
	            
	            Cursor phone = reContentResolverol.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, 
	                     null, 
	                     ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = " + contactId, 
	                     null, 
	                     null);
	             while (phone.moveToNext()) {
	            	 // 電話帳リストで一つ連絡人をクリックした、対応する電話番号を取得する
	            	 String phoneNumber = phone.getString(phone.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
	            	 // 電話をする
	            	 callPhone(phoneNumber);
	             }
	         }
		}
// ADD-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
    }

	/*
	 * @see android.app.Activity#onConfigurationChanged(android.content.res.Configuration)
	 */
	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		Log.d("MyApplication", "onConfigurationChanged() enter, config=" + newConfig.toString());
		super.onConfigurationChanged(newConfig);
		Log.d("MyApplication", "onConfigurationChanged() leave");
	}

	/**
	 * NFCタグ情報よりシステムコードを確認する。<br>
	 * システムコードが一致する場合、タグ情報を設定する。<br>
	 * @param  intent : NfcServiceからのインテント情報
	 * @return true : Gemini、false : Gemini以外
	 */
	private boolean checkNfcTag(Intent intent) {
		Log.d("MyApplication", "StartApp#checkNfcTag()");

		// タグ情報設定API(NFC向け)  ※ 2012/03/29 TypeB対応
		int ret;
		synchronized (mTouchRwTimeoutOccuredForNfc) {
			// NFC時のタッチリトライ設定(必要な場合)
			ret = nfcW.setTagInfoForNfc(intent, mTouchRwTimeoutOccuredForNfc);
			// TF-#4079 enableNfcのタイミングで mTouchRwTimeoutOccuredForNfc を初期化
			//mTouchRwTimeoutOccuredForNfc = false;
		}
		if (ret != nfcWrapper.RES_SUCCESS) {
			Log.d("MyApplication", "onNewIntent() setTagInfoForNfc ");
    		return false;
		}

		// タグ取得完了を通知する
    	jsB.notifyNfcReady();

		return true;
	}

	/**
	 * NFCのRFタグ取得有効フラグを設定する。<br>
	 * @param  flag : RFタグ取得有効フラグ
	 * @param  userIdCode : ユーザ識別コード
	 * @return none
	 */
	public void enableNfc(int flag, String userIdCode,  int designatedCategory, int timeoutSec) {
		Log.d("MyApplication", "StartApp#enableNfc() flag=" + flag + " userIdCode=" + userIdCode + " timeoutSec=" + timeoutSec);

		// NFCタグ取得許可フラグの設定
		if ((flag == ENABLE_NFC_RD) || (flag == ENABLE_NFC_RW) ||
			(flag == ENABLE_NFC_TIME) || (flag == ENABLE_NFC_REPAIR) ||
			(flag == ENABLE_NFC_USERID) || (flag == ENABLE_NFC_PRELOGIN) ||
			(flag == ENABLE_NFC_GETUSERINFO) || (flag == ENABLE_NFC_SETUSERINFO) ||
			(flag == ENABLE_NFC_DELUSERINFO) || (flag == ENABLE_NFC_RDMEASURE) ||
//CHG-ST 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応
			(flag == ENABLE_NFC_REGISTER) || (flag == ENABLE_NFC_RDCSDATA)){
//CHG-ED 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応
		    isEnableNfc = flag;

		    if (userIdCode.length() > 0) {
				Log.d("MyApplication", "StartApp#enableNfc : userIdCode.length() > 0");
			    mUserIdCode = Util.changeByteArray(userIdCode);
		    } else {
				Log.d("MyApplication", "StartApp#enableNfc : userIdCode.length() <= 0");
		    	mUserIdCode = USER_ID_CODE_DUMMY;
		    }

            mDesignatedCategory = designatedCategory;
	    	// 2012/08/02 #4177対応 add start
            mTimeoutSec = timeoutSec;
	    	// 2012/08/02 #4177対応 add end

//ADD-ST 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応
		    //CSデータ読み出しフラグの設定
		    if (isEnableNfc == ENABLE_NFC_RDCSDATA) {
			    Log.d("MyApplication", "StartApp#enableNfc : readCsDataFlag = true");
		    	nfcW.setReadCsDataFlag(true);
				Log.d("MyApplication", "StartApp#enableNfc : change ENABLE_NFC_RDCS => ENABLE_NFC_RD");
		    	isEnableNfc = ENABLE_NFC_RD;
		    } else {
			    Log.d("MyApplication", "StartApp#enableNfc : readCsDataFlag = false");
		    	nfcW.setReadCsDataFlag(false);
		    }
//ADD-ED 仕様変更作業管理 #21960: CSログ活用：故障診断サービス対応
			if (!isNfcExist) {
				Log.d("MyApplication", "StartApp#enableNfc : isNfcExist == false(FeliCa)");
				if (mTouchStat == TOUCH_OK) {   // タッチ可能
					Log.d("MyApplication", "StartApp#enableNfc : mTouchStat == TOUCH_OK");
					// タイムアウト設定
					nfcW.setPollingTimeout(timeoutSec);

					// #6913対応にて分岐を追加
					// isPoolingPauseがtrueの場合は、初期化のみ行い、nfcW.enableNfcは呼び出さない。
					if (!isPoolingPaused) {
						// 2012/09/10 #5106対応 add start
						synchronized (mTouchRwTimeoutOccuredForNfc) {
							mTouchRwTimeoutOccuredForNfc = false;
						}
						// 2012/09/10 #5106対応 add end
						// Felica接続処理
						nfcW.enableNfc(this, false);
					} else {
						Log.d("MyApplication", "StartApp#enableNfc : main Activity is pausing.");
					}

				} else if (mTouchStat == TOUCH_NG) {  // タッチ機能なし
					Log.d("MyApplication", "StartApp#enableNfc : mTouchStat == TOUCH_NG");
					jsB.notifyNfcErrorForJava(nfcWrapper.RES_ERROR_NFC_NOT_EQUIPPED);
				    isEnableNfc = DISABLE_NFC;
				} else { // 初期化エラー
			    	// 2012/08/02 #4177対応 modified start
					//Log.d("MyApplication", "StartApp#enableNfc : Initial Error");
					//jsB.notifyNfcErrorForJava(mTouchStat);
				    //isEnableNfc = DISABLE_NFC;
			    	// Felicaが利用可能かチェック
	    			Log.d("MyApplication", "StartApp#enableNfc : call checkNfcOrFelicaAvailability()");
	    			mCheckTouchStat = true;
	    			nfcWrapper.checkNfcOrFelicaAvailability(this);
			    	// 2012/08/02 #4177対応 modified end
				}
			} else {
				Log.d("MyApplication", "StartApp#enableNfc : isNfcExist == true(NFC)");
				// TF-#4460対応(長坂)
		    	// NFC設定ON/OFFの判定
				isNfcAvailable = Util.checkNfcAvailable(this.getApplicationContext());
				if (!isNfcAvailable){
					Log.d("MyApplication", "StartApp#enableNfc : isNfcAvailable == false");
			    	// 2012/08/21 #4487対応 modified start
			    	// Felicaが利用可能かチェック
	    			mCheckTouchStat = true;
	    			nfcWrapper.checkNfcOrFelicaAvailability(this);
			    	// 2012/08/21 #4487対応 modified end
				} else {
					Log.d("MyApplication", "StartApp#enableNfc : isNfcAvailable == true");

					// TF-#4079 enableNfcのタイミングで mTouchRwTimeoutOccuredForNfc を初期化
					synchronized (mTouchRwTimeoutOccuredForNfc) {
						mTouchRwTimeoutOccuredForNfc = false;
					}

					// 先行して起動中のポーリングタイマーがある可能性があるので
					// 一度停止する。
					stopNfcPollingTimer();

					// タイムアウト時間が指定されている場合は、NFCのポーリングタイマーを起動する。
					if (timeoutSec > 0) {
						startNfcPollingTimer(timeoutSec);
					}
				}
			}
		} else {
			// 引数不正
			Log.e("MyApplication", "StartApp#enableNfc : Illegal argument !!");
		    isEnableNfc = DISABLE_NFC;
		}
	}
	/**
	 * NFCのRFタグ取得有効フラグを解除する。(onPause時)<br>
	 * @param  none
	 * @return none
	 */
	public void disableNfcForPause() {
		// #6913の対応にて追加
		// onPauseの場合はこちらのメソッドが呼ばれる。
		Log.d("MyApplication", "disableNfcForPause()");

		nfcW.disableNfc(this);

	}

	/**
	 * NFCのRFタグ取得有効フラグを解除する。<br>
	 * @param  none
	 * @return none
	 */
	public void disableNfc() {
		Log.d("MyApplication", "StartApp#disableNfc()");

		// 現在利用中のNFC（or Felica）を判定する
		if (!nfcW.mNfcPreferred) {	// 2012/08/21 #4487対応 modified
			Log.d("MyApplication", "StartApp#disableNfc : mNfcPreferred == false");
			// NFCタグ取得許可フラグの解除


			// #6913の対応にて修正
			// onPause以外の場合は、フラグに関わらずisEnableNfcをDisableに設定する。
			// if (!isPoolingPaused) {
			//	Log.d("MyApplication", "StartApp#disableNfc : isPoolingPaused == false");
			isEnableNfc = DISABLE_NFC;
			//}

//			//　Felica切断処理
//			if (mTouchStat == 0) {
//				nfcW.disableNfc(this);
//			}
			// Felicaロック時にdisableNfcしないと再開できない。
			nfcW.disableNfc(this);
		} else {
			Log.d("MyApplication", "StartApp#disableNfc : mNfcPreferred == true");
	        isEnableNfc = DISABLE_NFC;
			//　ポーリングタイマーの停止
	        stopNfcPollingTimer();
		}
	}

	/**
	 * 効果音をロードする。<br>
	 * @param  none
	 * @return none
	 */
	private void loadSound() {
		Log.i("MyApplication", "loadSound()");
		// 102Pでは「STREAM_NOTIFICATION」の音量が制御できない(バグ?)ため「STREAM_MUSIC」に変更
    	//sp = new SoundPool(1, AudioManager.STREAM_NOTIFICATION, 0);
    	sp = new SoundPool(1, AudioManager.STREAM_MUSIC, 0);
    	soundId[0] = sp.load(this, R.raw.touch_success, 1);
    	soundId[1] = sp.load(this, R.raw.touch_failure, 1);
	}

	/**
	 * 効果音をアンロードする。<br>
	 * @param  none
	 * @return none
	 */
	private void unLoadSound() {
		Log.i("MyApplication", "unLoadSound()");
		for (int i = 0; i < soundId.length; i++) {
	        sp.stop(soundId[i]);
	        sp.unload(soundId[i]);
	        sp.release();
		}
	}

	/**
	 * 効果音を鳴らす。<br>
	 * @param  index: 効果音種別(0=成功音,1=失敗音)
	 * @return none
	 */
	public void playSound(int index) {
		Log.i("MyApplication", "playSound(mLeftVol="+mLeftVol+", mRightVol="+mRightVol+")");
    	sp.play(soundId[index], mLeftVol, mRightVol, 0, 0, 1.0F);
	}

	/**
	 * 効果音を鳴らす。(音量指定つき)<br>
	 * @param  index: 効果音種別(0=成功音,1=失敗音)
	 * @param  volume: 音量(0.0F～1.0F)
	 * @return none
	 */
	public void playSound(int index, float volume) {
		Log.i("MyApplication", "playSound(volume="+volume+")");
    	sp.play(soundId[index], volume, volume, 0, 0, 1.0F);
	}

	/**
	 * NFCのRFタグ取得有効フラグを取得する。<br>
	 * @param  none
	 * @return none
	 */
	public int getNfcMode() {
		Log.d("MyApplication", "getNfcMode()");
	    return isEnableNfc;
	}

	/**
	 * JS側へFelica完了通知する。<br>
	 * @param  none
	 * @return none
	 */
	public void notifyNfcFinish() {
		Log.d("MyApplication", "StartApp#notifyNfcFinish()");
	    // 完了通知する
    	jsB.notifyNfcFinish();
		
		// JQM画面の場合、表示中の入力P.U.を閉じる
    	closeInputDialog();
	}
	
	public void closeInputDialog() {
		if (inputDialog != null) {
			Log.d("MyApplication","close inputDialog");
   			inputDialog.dismiss();
   			inputDialog = null;
   			inputDialogFlg = false;
		}
	}

	/**
	 * 自動消灯をOFF <br>
	 * @param  none
	 * @return none
	 */
	public void sleepScreenOff () {
		Log.d("MyApplication", "sleepScreenOff()");
        try{
            if( fullWakeLock == null ) {
                fullWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, "addKeepScreenOn");
// ADD-START [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
                fullWakeLock.setReferenceCounted(false);    // リファレンスカウンタをOFFにする
// ADD-END   [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
            }
            if( fullWakeLockFlg == false ) {
// DEL-START [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
//                 fullWakeLock.acquire();
// 	            fullWakeLockFlg = true;
// DEL-END   [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
// ADD-START [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
	            fullWakeLockFlg = true;
                fullWakeLock.acquire();
// ADD-END   [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
            }
        }catch (Exception e) {
        	Log.e("MyApplication", "Exception: " + e);
            fullWakeLock = null;
	        fullWakeLockFlg = false;
            e.printStackTrace();
        }
    }

	/**
	 * 自動消灯をON <br>
	 * @param  none
	 * @return none
	 */
	public void sleepScreenOn () {
		Log.d("MyApplication", "sleepScreenOn()");
        try{
            if( fullWakeLock != null && fullWakeLockFlg == true ){
// DEL-START [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
//                fullWakeLock.release();
//	            fullWakeLockFlg = false;
// DEL-END   [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
// ADD-START [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
                fullWakeLockFlg = false;
                fullWakeLock.release();
// ADD-END   [欠陥管理 #5378]【機種依存？】レシピ表示中に画面ロックがかかってしまう
            }
        }catch (Exception e) {
        	Log.e("MyApplication", "Exception: " + e);
            e.printStackTrace();
        }
    }

	/**
	 * カメラアプリを起動する。<br>
	 * 撮影画像を保存する際、onActivityResult()が呼び出される。<br>
	 * @param  none
	 * @return none
	 */
	public void invokeCamera() {
		Log.i("MyApplication", "invokeCamera()");

// ADD-ST: TF-#4669 2012/08/08 (山形)
		//不要となったメモリを解放
		if (jsB.mImageData != null) {
			Log.i("MyApplication", "release mImageData");
			jsB.mImageData = null;
		}
// ADD-ED: TF-#4669 2012/08/08 (山形)

        PackageManager mManager = getPackageManager();

        if (mManager.hasSystemFeature(PackageManager.FEATURE_CAMERA)){
            // this device has a camera
        } else {
            // no camera on this device
            //String message = "カメラ機能に対応していない可能性があります";
            //Toast.makeText(this, message, Toast.LENGTH_LONG).show();
            jsB.notifyNotCamera();
            return;
        }

        String state = Environment.getExternalStorageState();
        if (!Environment.MEDIA_MOUNTED.equals(state)) {
		    // SDカードが読み書きできない場合、
            //String message = "SDカードをご確認ください";
            //Toast.makeText(this, message, Toast.LENGTH_LONG).show();
            jsB.notifyNotMediaMounted();
            return;
        }

		// カメラ起動
		Log.d("MyApplication", "Send intent to launch camera");
		Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
		File file = new File(Environment.getExternalStorageDirectory(), "gemini000.tmp"); // URI取得用一時ファイル
		intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));
		//CHG-ST:TF-#5622 2012/11/13 (山形)
		try {
			startActivityForResult(intent, REQUEST_CAMERA);
		} catch (Exception e) {
			Log.e("MyApplication", "Exception: " + e);
			e.printStackTrace();
			// カメラアプリの起動に失敗した場合
			String message = "カメラアプリが起動できませんでした";
			Toast.makeText(this, message, Toast.LENGTH_LONG).show();
			return;
		}
		//CHG-ED:TF-#5622 2012/11/13 (山形)
	}

	/**
	 * ギャラリーアプリを起動する。<br>
	 * 画像選択する際、onActivityResult()が呼び出される。<br>
	 * @param  none
	 * @return none
	 */
	public void invokeGallery() {
		Log.i("MyApplication", "invokeGallery()");

        String state = Environment.getExternalStorageState();
        if (!Environment.MEDIA_MOUNTED.equals(state)) {
		    // SDカードが読み書きできない場合、
            //String message = "SDカードをご確認ください";
            //Toast.makeText(this, message, Toast.LENGTH_LONG).show();
            jsB.notifyNotMediaMounted();
            return;
        }

		// インテント設定
		Intent intent = new Intent(Intent.ACTION_PICK);
		// とりあえずストレージ内の全イメージ画像を対象
		intent.setType("image/*");
		// ギャラリー表示
		try {
			startActivityForResult(intent, REQUEST_GALLERY);
		} catch (Exception e) {
        	Log.e("MyApplication", "Exception: " + e);
            e.printStackTrace();
            // 写真の取得に失敗した場合
            String message = "写真の取得に失敗しました";
            Toast.makeText(this, message, Toast.LENGTH_LONG).show();
			return;
		}
	}

	/**
	 * メールアプリを起動する。<br>
	 * @param  none
	 * @return none
	 */
	public void invokeMail(String subject, String text) {
		Log.i("MyApplication", "invokeMail()");

		//SubjectをURLエンコードする
		String encodedSubject;
		try {
			encodedSubject = java.net.URLEncoder.encode(subject, "UTF-8").replaceAll("\\+","%20");
		} catch (Exception e) {
			Log.d("MyApplication", "subject: encode failed");
			e.printStackTrace();
			encodedSubject = null;
		}
		//メッセージをURLエンコードする。
		String encodedBody;
		try {
			encodedBody = java.net.URLEncoder.encode(text, "UTF-8").replaceAll("\\+", "%20");
		} catch (Exception e) {
			Log.d("MyApplication", "text: encode failed");
			e.printStackTrace();
			encodedBody = null;
		}
		//URIを組み立ててメーラを起動する。
		Uri uri = Uri.parse("mailto:?subject="+encodedSubject+"&body="+encodedBody);
		Intent intent = new Intent(Intent.ACTION_SENDTO, uri);
		//intent.putExtra(Intent.EXTRA_SUBJECT, subject);	//一部のメーラでサポートされていない模様
		//intent.putExtra(Intent.EXTRA_TEXT, text);			//一部のメーラでサポートされていない模様
		//intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
		try {
			//startActivityForResult(intent, REQUEST_MAIL);
            startActivity(intent);
		} catch	(Exception e) {
        	Log.e("MyApplication", "Exception: " + e);
			e.printStackTrace();
		    // メールアプリの起動に失敗した場合
		    String message = "メールアプリが起動できませんでした";
		    Toast.makeText(this, message, Toast.LENGTH_LONG).show();
			return;
		}
	}

    // ADD-ST TF-#8093 AVC連携 取説DL 礒沢 2013-02-19
    /**
     * PDFをを開く<br>
     * @param  file : ファイルパス<br>
     * @return 処理結果<br>
     *                    0 : 起動成功<br>
     *                   -2 : 起動失敗(開けるアプリがない)<br>
     *                   -3 : 起動失敗(その他のエラー)<br>
     */
    public int invokePdf(String file) {
        Log.i("MyApplication", "invokePdf() file=" + file);

        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_VIEW);
        intent.setDataAndType(Uri.parse(file), "application/pdf");

        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            Log.d("MyApplication", "ActivityNotFoundException: " + e);
            // アプリがない
            return -2;
        } catch (Exception e) {
            Log.e("MyApplication", "Exception: " + e);
            e.printStackTrace();
            return -3;
        }

        //起動成功
        return 0;
    }
    // ADD-ED TF-#8093 AVC連携 取説DL 礒沢 2013-02-19

	/**
	 * 効果音の音量を設定する。<br>
	 * @param  volume : 音量
	 * @return none
	 */
	public void setSoundVolume(float volume) {
		Log.i("MyApplication", "setSoundVolume() volume=" + volume);

		mLeftVol = volume;
		mRightVol = volume;
	}

	/**
	 * 自アプリを終了する。<br>
	 * @param  none
	 * @return none
	 */
	public void finishApp() {
		Log.i("MyApplication", "finishApp()");
		finish();
	}

	/**
	 * ローカルのエラー画面を表示する。
	 * @param errHtml エラー画面
	 *
	 */
    public void loadErrUrl(String errHtml) {
	    String url = "file:///android_asset/www/err/12a/" + errHtml;

    	Log.d("MyApplication", "loadErrUrl() loadUrl:" + url);
    	wv.loadUrl(url);
    }

	/**
	 * ローカルのエラー画面を表示する。
	 * @param systemErrCode システムエラーコード
	 * @param errMessage エラーメッセージ
	 * @param btnNmae 復帰ボタン名称
	 *
	 */
    public void loadErrUrl(String systemErrCode, String errMessage, String btnName) {
    	// TF-#2516 対応 (2012/06/14 長坂)
    	setWhTimerUseFlag("false");

	    // システムエラーコードを設定
	    this.systemErrCode = systemErrCode;
	    // エラーメッセージを設定
	    this.errMessage = errMessage;
	    // 復帰ボタン名称を設定
	    this.btnName = btnName;

	    String url = "file:///android_asset/www/err/12a/err_common.html";
    	Log.d("MyApplication", "loadErrUrl() :loadUrl = " + url + ", systemErrCode = " + systemErrCode + ", errMessage = " + errMessage + ", btnName = " + btnName);

    	wv.loadUrl(url);
    }

    /**
     * ポーリングエラー
     * @param resultCode ポーリング結果
     */
    private void onErrorPolling(int resultCode) {
		disableNfc();
		jsB.notifyNfcErrorForJava(resultCode);
    }

    /**
     * タッチ状態を返却
     * @return タッチの状態（99：未判定、0：可能、1：未搭載、左記以外：エラー）
     */
    public int getTouchStat() {
    	return mTouchStat;
    }

    /**
     * 読み込み中ダイアログ不要な画面か
     * @param url 表示画面のURL
     * @return true：不要、false：不要でない
     */
    private boolean isNoDialogHtml(String url) {
    	for ( String html : mNoDialogList){
    		if (url.contains(html)) {
    			Log.d("MyApplication", "No Progrss Dialog  ->Url:" + url);
    			return true;
    		}
    	}
    	return false;
    }

    /**
     * メニュー表示不可な画面か
     * @param url 表示画面のURL
     * @return true：不要、false：不要でない
     */
    private boolean isNoMenuHtml(String url) {
    	for ( String html : mNoMenuList){
    		if (url.contains(html)) {
    			Log.d("MyApplication", "No Menu  ->Url:" + url);
    			return true;
    		}
    	}
    	return false;
    }
	/**
	 * 入力ダイアログ表示フラグを取得する。<br>
	 * @return 入力ダイアログ表示フラグ（true:表示中、false:非表示）
	 */
    public boolean getInputDialogFlg() {
		Log.i("MyApplication", "getInputDialogFlg()");
		return inputDialogFlg;
    }

/* ADD-START TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */

    /**
     * 引数１は引数２の整数倍であるかをチェックする
     * @param inputValStr チェック対象値文字列
     * @param intervalStr　刻み文字列
     * @return true 引数１は引数２の整数倍である
     *         false 引数１は引数２の整数倍でない
     */
    private static boolean canDiv(String inputValStr, String intervalStr){
    	Log.i("MyApplication", "canDiv()");
    	Log.i("MyApplication", "[inputValStr]:" + inputValStr);
    	Log.i("MyApplication", "[intervalStr]:" + intervalStr);
    	boolean result = false;
    	int bitCntAfterPoint  = 0;//小数点後の最大桁数
    	int bitCntAfterPoint1 = 0;//inputValStr小数点後の桁数
    	int bitCntAfterPoint2 = 0;//intervalStr小数点後の桁数
    	if(inputValStr.contains(".")){
    		bitCntAfterPoint1 = inputValStr.split("\\.")[1].length();
    	}
    	if(intervalStr.contains(".")){
    		bitCntAfterPoint2 = intervalStr.split("\\.")[1].length();
    	}
    	bitCntAfterPoint = Math.max(bitCntAfterPoint1, bitCntAfterPoint2);

    	//小数点を削除して、最大小数点後桁まで0を補足する
    	inputValStr = inputValStr.replaceAll("\\.", "");
    	for(int i=bitCntAfterPoint1; i<bitCntAfterPoint; i++){
    		inputValStr = inputValStr + "0";
    	}
    	intervalStr = intervalStr.replaceAll("\\.", "");
    	for(int i=bitCntAfterPoint2; i<bitCntAfterPoint; i++){
    		intervalStr = intervalStr + "0";
    	}
    	Log.i("MyApplication", "整数文字列に転換結果：");
    	Log.i("MyApplication", "[inputValStr]:" + inputValStr);
    	Log.i("MyApplication", "[intervalStr]:" + intervalStr);

    	int inputVal = Integer.valueOf(inputValStr);
    	int interVal = Integer.valueOf(intervalStr);
    	Log.i("MyApplication", "整数に転換結果：");
    	Log.i("MyApplication", "[inputVal]:" + inputVal);
    	Log.i("MyApplication", "[interval]:" + interVal);

    	if(inputVal % interVal == 0){
    		result = true;
    	}
    	else{
    		result = false;
    	}

    	Log.i("MyApplication", "[RET]:" + result);
    	return result;
    }
/* ADD-END   TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
	/**
	 * 入力ダイアログを表示する。<br>
	 * @param  初期入力値
	 * @param  入力ダイアログのタイトル
	 * @param  入力ダイアログの初期入力値
	 * @param  入力ダイアログの入力タイプ
	 * @param  入力可能な最大文字数
	 * @param  入力可能な最大数
	 * @param  入力可能な最小数
	 * @param  入力可能な刻み
	 * @param  入力値単位
	 */
    public void showInputDialog(String title, final String inText, final String inputType, final int maxLength,
/* CHG-START TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
    		//final String maxVal, final String minVal, final float interVal) {
/* CHG-START TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
    		// final String maxVal, final String minVal, final String interVal) {
            final String maxVal, final String minVal, final String interVal, final String unitVal) {
/* CHG-END TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
/* CHG-END   TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
		Log.i("MyApplication", "showInputDialog()");
		Log.i("maxVal", maxVal);
		Log.i("minVal", minVal);
		Log.i("interVal", interVal);
/* ADD-START TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
        Log.i("unitVal", unitVal);
/* ADD-END TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */

		inputDialogFlg = true;

        final float max = Float.parseFloat(maxVal);
        final float min = Float.parseFloat(minVal);

		// テキスト入力を受け付けるビューを作成
		final EditText editView = new EditText(StartApp.this);

		// 初期入力値を設定
		editView.setText(inText, BufferType.NORMAL);

		// 入力タイプを設定
/* CHG-ST #18639：【携帯アプリ】新無線GW(TC8)機器コード体系変更 PSDCD李 2014-07-08 */
		if (("text".equals(inputType)) || ("half_char_number".equals(inputType))) {
			editView.setInputType(InputType.TYPE_CLASS_TEXT);
		} else if ("number".equals(inputType) || ("secret".equals(inputType)) || ("half_number".equals(inputType))) {
/* CHG-ED #18639：【携帯アプリ】新無線GW(TC8)機器コード体系変更 PSDCD李 2014-07-08 */
			editView.setInputType(InputType.TYPE_CLASS_NUMBER);
		} else if ("decimal".equals(inputType)) {
			editView.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
		} else if ("password".equals(inputType)){
			editView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
		}

		// 変更チェック用フィルタ（４バイト文字も１文字としてカウントし、maxLength以上の入力を切り捨てる）
		// ※InputFilter.LengthFilterでは、４バイト文字が２文字としてカウントされてしてしまうため独自実装
		class MyFilter implements InputFilter {
			public CharSequence filter(CharSequence source, int start, int end,
					Spanned dest, int dstart, int dend) {
				// 変更前の文字列長
				int prevLen = dest.toString().codePointCount(0, dest.length());
				// 削除される文字列長
				int delLen = dest.toString().codePointCount(dstart, dend);
				// 追加される文字列長
				int addLen = source.toString().codePointCount(0, source.length());

				// 追加可能な文字列長
				int keep = maxLength - (prevLen - delLen);
				if (keep <= 0) {
					return "";
				} else if (addLen <= keep) {
					return null; // keep original
				} else {
					// 変更後の文字列が最大文字列長を越える場合
					int offset = source.toString().offsetByCodePoints(0, maxLength - (prevLen - delLen));
					// 追加される文字列のうち余分な部分を切り捨て
					return source.subSequence(0, offset);
				}
			}
		}
		editView.setFilters(new InputFilter[] { new MyFilter() });
		// 最大表示行数を設定
		editView.setMaxLines(5);

		editView.selectAll();

		AlertDialog.Builder builder = new AlertDialog.Builder(StartApp.this);

		// アイコン設定
		builder.setIcon(android.R.drawable.ic_dialog_info);
		// タイトル設定
		String inputRangeStr = "";
		if ((("number".equals(inputType)) || ("decimal".equals(inputType))) &&
				(min != max) &&
			(!Float.isNaN(max))) {
/* CHG-START TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
			// inputRangeStr = " (" + minVal + "～" + maxVal + " " + String.valueOf(interVal) + ")";
            inputRangeStr = " (" + minVal + "～" + maxVal + " " + String.valueOf(interVal) + unitVal + "単位)";
/* CHG-END TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
/* CHG-START TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
		    //if(interVal % 1 == 0){
			if(!interVal.contains(".")){
			    //inputRangeStr = " (" + minVal + "～" + maxVal + " " + String.valueOf((int) interVal) + ")";
/* CHG-START TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
				// inputRangeStr = " (" + minVal + "～" + maxVal + " " + interVal + ")";
                inputRangeStr = " (" + minVal + "～" + maxVal + " " + interVal + unitVal + "単位)";
/* CHG-END TF-#2114:ポップアップ画面で値の範囲と刻みが分かりにくい対応 PSDCD劉 2012-06-13 */
/* CHG-END   TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
			}
		}
		// 入力タイプはストリング時のタイトル設定
		if (("secret".equals(inputType)) && (min != max) && (!Float.isNaN(max))){
			if(maxLength != 1){
				if(min < 10){
					String minFall = String.format("%0" + maxLength + "d",(int)min);
				    inputRangeStr = " (" + minFall + "～" + maxVal + ") ";
				}
		    } else {
		    	inputRangeStr = " (" + minVal + "～" + maxVal + ") ";
		    }
		}
/* CHG-START TF-#2114:ユーザー情報入力用のポップアップ画面で、値の範囲と刻みが分かりにくい対応 PSDCD張 2012-06-19 */
		if(title.length() > 0){
			//タイトル文字列がある場合、入力範囲はメッセージとして表示する
			builder.setTitle(title);
			if(inputRangeStr.length() > 0){
				//入力範囲文字列ある場合だけメッセージとして表示する
				builder.setMessage(inputRangeStr);
			}
		}
		else{
			//タイトル文字列がない場合、入力範囲文字列はタイトルとして表示する
		    builder.setTitle(title + inputRangeStr);
		}
/* CHG-END   TF-#2114:ユーザー情報入力用のポップアップ画面で、値の範囲と刻みが分かりにくい対応 PSDCD張 2012-06-19 */

		builder.setView(editView);
		// バックキーによるキャンセル不可
		builder.setCancelable(false);
		builder.setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				// Disable Search key
				if (keyCode == KeyEvent.KEYCODE_SEARCH) {
					return true;
				}
				return false;
			}
		});

        final InputMethodManager inputMethodManager;
        inputMethodManager =(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);

		builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
            	if ((("number".equals(inputType)) || ("decimal".equals(inputType))) &&
            		(min != max) &&
            		(!Float.isNaN(max))){
                	float inputVal = 0;
                	boolean needCheck = true;
                	try{
                	    inputVal = Float.parseFloat(editView.getText().toString());
                	}catch(Exception e){
                		//空白の場合、チェックしない
                		needCheck = false;
                	}
/* DEL-START TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
                	//float innerInterVal = interVal;
/* DEL-END TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
                    //★入力値範囲・間隔チェック
                	if ( needCheck && ((inputVal < min) ||
                			(inputVal > max) ||
                			editView.getText().toString().startsWith(".") ||
                			editView.getText().toString().endsWith(".") ||
/* CHG-START TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
                			//(((int)(inputVal*100)) % ((int)(innerInterVal*100)) != 0)) {
                			!StartApp.canDiv(editView.getText().toString(), interVal))){
/* CHG-END   TF-#2503:【携帯T＠UT】手入力での数値チェック問題（33.6が入力できない）対応 PSDCD張 2012-06-07 */
                        //★初期入力値を表示
                		editView.setText(inText, BufferType.NORMAL);
                        //★TBD:FOCUS取得必要？
                        editView.selectAll();
                        java.lang.reflect.Field field;
						try {
							field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
	                        field.setAccessible(true);
	                        field.set(dialog, false);
						} catch (SecurityException e) {
							e.printStackTrace();
						} catch (NoSuchFieldException e) {
							e.printStackTrace();
						} catch (IllegalArgumentException e) {
							e.printStackTrace();
						} catch (IllegalAccessException e) {
							e.printStackTrace();
						}
                	  } else{
	                	//★正常処理
	            		inputDialogFlg = false;
	                	jsB.onInputText(editView.getText().toString(), whichButton);
	                    inputMethodManager.hideSoftInputFromWindow(editView.getApplicationWindowToken(),0);
	                    java.lang.reflect.Field field;
						try {
							field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
	                        field.setAccessible(true);
	                        field.set(dialog, true);
						} catch (SecurityException e) {
							e.printStackTrace();
						} catch (NoSuchFieldException e) {
							e.printStackTrace();
						} catch (IllegalArgumentException e) {
							e.printStackTrace();
						} catch (IllegalAccessException e) {
							e.printStackTrace();
						}
                	}
                // 入力タイプはストリング時のチェック処理
                } else if ("secret".equals(inputType) &&
						(minVal != maxVal) &&
						(!Float.isNaN(max))){
						String inputVal1 = null;
						boolean needCheck1 = true;
						inputVal1 = editView.getText().toString();
						if(inputVal1.length() == 0){
							//空白の場合、チェックしない
							needCheck1 = false;
						}
						//★入力値範囲・間隔チェック
						if ( needCheck1 && (((Integer.parseInt(inputVal1)) < min) ||
								((Integer.parseInt(inputVal1)) > max) || (inputVal1.length() != maxLength))) {
							//★初期入力値を表示
							editView.setText(inText, BufferType.NORMAL);
							//★TBD:FOCUS取得必要？
							editView.selectAll();
							java.lang.reflect.Field field;
							try {
								field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
								field.setAccessible(true);
								field.set(dialog, false);
							} catch (SecurityException e) {
								e.printStackTrace();
							} catch (NoSuchFieldException e) {
								e.printStackTrace();
							} catch (IllegalArgumentException e) {
								e.printStackTrace();
							} catch (IllegalAccessException e) {
								e.printStackTrace();
							}
						} else{
	                	//★正常処理
	            		inputDialogFlg = false;
	                	jsB.onInputText(editView.getText().toString(), whichButton);
	                    inputMethodManager.hideSoftInputFromWindow(editView.getApplicationWindowToken(),0);
	                    java.lang.reflect.Field field;
						try {
							field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
	                        field.setAccessible(true);
	                        field.set(dialog, true);
						} catch (SecurityException e) {
							e.printStackTrace();
						} catch (NoSuchFieldException e) {
							e.printStackTrace();
						} catch (IllegalArgumentException e) {
							e.printStackTrace();
						} catch (IllegalAccessException e) {
							e.printStackTrace();
						}
                	}
                } else {
                	//★正常処理
	        		inputDialogFlg = false;
/* CHG-ST #18639：【携帯アプリ】新無線GW(TC8)機器コード体系変更 PSDCD李 2014-07-14 */
	        		if (inputType.equals("half_char_number") || inputType.equals("half_number")) {
	        			//半角に変換
	        			String textStr = Util.transformFullToHalf(editView.getText().toString());
	        			//大文字に変換
	        			textStr = textStr.toUpperCase();
	        			jsB.onInputText(textStr, whichButton);
	        		} else {
	        			jsB.onInputText(editView.getText().toString(), whichButton);
	        		}
/* CHG-ED #18639：【携帯アプリ】新無線GW(TC8)機器コード体系変更 PSDCD李 2014-07-14 */
	                inputMethodManager.hideSoftInputFromWindow(editView.getApplicationWindowToken(),0);
	                java.lang.reflect.Field field;
					try {
						field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
                        field.setAccessible(true);
                        field.set(dialog, true);
					} catch (SecurityException e) {
						e.printStackTrace();
					} catch (NoSuchFieldException e) {
						e.printStackTrace();
					} catch (IllegalArgumentException e) {
						e.printStackTrace();
					} catch (IllegalAccessException e) {
						e.printStackTrace();
					}
                }
            }
        });
		builder.setNegativeButton("キャンセル", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
        		inputDialogFlg = false;
                jsB.onInputText(editView.getText().toString(), whichButton);

                inputMethodManager.hideSoftInputFromWindow(editView.getApplicationWindowToken(),0);
                java.lang.reflect.Field field;
				try {
					field = dialog.getClass().getSuperclass().getDeclaredField("mShowing");
                    field.setAccessible(true);
                    field.set(dialog, true);
				} catch (SecurityException e) {
					e.printStackTrace();
				} catch (NoSuchFieldException e) {
					e.printStackTrace();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
            }
        });
		final AlertDialog softInputDialog;
		softInputDialog = builder.create();

		// ソフトキーボード
		editView.setOnFocusChangeListener(new OnFocusChangeListener() {
		        @Override
		        public void onFocusChange(View v, boolean hasFocus) {
		            if (hasFocus) {
		            	softInputDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
		            }
		        }
		 });

		// 画面を上部に表示
		WindowManager.LayoutParams wmlp = softInputDialog.getWindow().getAttributes();
		wmlp.gravity=Gravity.TOP;   //画面上部に表示
		softInputDialog.getWindow().setAttributes(wmlp);

		Log.d("MyApplication", "Input Dialog show");
		softInputDialog.show();
		inputDialog = softInputDialog;

    }

    // TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
    /**
     * プログレスダイアログを表示する。<br>
     * Java側用
     */
    private void openProgressDialogInner() {
    	Log.i("MyApplication", "openProgressDialogInner()");
    	// エラーが発生された場合、JS側のフラグリセット処理が実行できない場合、
    	// プログレスバーが閉じられないを防止するため、リセットする
    	progressDialogFlag = true;
    	openProgressDialog();
    }

	/**
	 * プログレスダイアログを表示する。<br>
	 * JS側用
	 */
	public void openProgressDialog() {
		Log.i("MyApplication", "openProgressDialog()");

		// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
		// progressDialogFlagフラグリセットはopenProgressDialogInnerに移行

		// 読み込み中ダイアログ表示（スプラッシュ画面表示中は表示しない）
	    if (mWaitDialog == null && splashImage == null) {
	    	mWaitDialog = new ProgressDialog(wv.getContext(), R.style.Theme_ProgressDialog);
	    	mWaitDialog.setMessage("読み込み中...");
	    	mWaitDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
	    	mWaitDialog.setCancelable(false);
	    	mWaitDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
	    		@Override
	    		public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
	    			// Disable Search key
	    			if (keyCode == KeyEvent.KEYCODE_SEARCH) {
	    				return true;
	    			}
	    			return false;
	    		}
	    	});
	    	mWaitDialog.show();
	    }

	    InputMethodManager inputMethodManager =
	        (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
	    inputMethodManager.hideSoftInputFromWindow(wv.getWindowToken(), 0);

    }

	/**
	 * プログレスダイアログを閉じる。<br>
	 */
	public void closeProgressDialog() {
		Log.i("MyApplication", "closeProgressDialog()");

		// TF-#1915 検証NG対応(ProgressDialogの処理) (2012/07/02 原)
		if( progressDialogFlag == true ) {
			// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
			if(pageTransactionFlag) {
				Log.d("MyApplication", "Before page transaction finish, don't close dialog.");
				return;
			}
			// 読み込み中ダイアログをクローズ
			if (mWaitDialog != null) {
				forceRedraw();
				mWaitDialog.dismiss();
				mWaitDialog = null;
			}
		}
    }

    /**
     * アプリ終了確認ダイアログを表示する
     */
    public void showConfirmFinishDialog() {
		Log.i("MyApplication", "showConfirmFinishDialog()");

		// TF-#3784 アプリ終了確認P.U.重複表示 2012/07/16 張
        if(this.finishAppDlg != null) {
        	if(!this.finishAppDlg.isShowing()) {
        		Log.d("MyApplication", "Redisplay app finish dialog.");
        		this.finishAppDlg.show();
        	}
        	else {
        		Log.d("MyApplication", "Don't redisplay app finish dialog.");
        	}
        	return;
        }
        else {
        	Log.d("MyApplication", "Display app finish dialog first time.");
        	this.finishAppDlg = new AlertDialog.Builder(this).create();
        }
		//b.setTitle("終了確認");
        this.finishAppDlg.setMessage("アプリケーションを終了しますか？");
        this.finishAppDlg.setButton("はい", new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int whichButton) {
				finishApp();
			}
		});
        this.finishAppDlg.setButton2("いいえ", new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int whichButton) {
				// NOP
			}
		});
		this.finishAppDlg.show();
	}


    /**
	 * 画面描画停止ガード処理（WebViewCore強制再描画）
	 */
	private void forceRedraw() {
		if (this.forseRedrawFlag) {
			Log.i("MyApplication", "forceRedraw()");

			try{
				// ProgressDialogの表示前後で画面描画が停止してしまう事象への対処
				// WebViewの非公開メソッドnotifySelectDialogDismissedを強制的に呼び出す。
				Method mh = WebView.class.getDeclaredMethod("notifySelectDialogDismissed");
				mh.setAccessible(true);
				mh.invoke(this.wv);
			} catch(Throwable e) {
				forseRedrawFlag = false;
				Log.e("MyApplication", "forceRedrawFailed() : " + e.toString());
				return;
			}
		}
	}

	/**
	 * アドバイスの動画を再生する。<br>
	 */
	public void showAdviceVideo(String url) {
		Log.i("MyApplication", "showAdviceVideo()");

		try {
	        Uri uri = Uri.parse(url);
	        Intent intent = new Intent(Intent.ACTION_VIEW);
	        intent.setData(uri);
	        startActivity(intent);
		} catch(Exception e) {
        	Log.e("MyApplication", "Exception: " + e);
        	//Log.e("ERROR", e.toString());
			String message = "動画が再生できませんでした";
			Toast.makeText(this, message, Toast.LENGTH_LONG).show();
        }
    }

    /**
	 * システムエラーコードを取得する。<br>
	 * @return システムエラーコード
	 */
    public String getSystemErrCode() {
		Log.i("MyApplication", "getSystemErrCode()");
		return this.systemErrCode;
    }

    /**
	 * エラーメッセージを取得する。<br>
	 * @return エラーメッセージ
	 */
    public String getErrMessage() {
		Log.i("MyApplication", "getErrMessage()");
		return this.errMessage;
    }

    /**
	 * 復帰ボタン名称を取得する。<br>
	 * @return 復帰ボタン名称
	 */
    public String getBtnName() {
		Log.i("MyApplication", "getBtnName()");
		return this.btnName;
    }

    /**
	 * スプラッシュ画面閉じる。<br>
	 */
    public void closeSplashImage() {
		if (splashImage != null) {
			Log.i("MyApplication", "closeSplashImage()");
			splashEnd = java.lang.System.currentTimeMillis();

			if (splashEnd - splashStart < SPLASH_TIME) {
				// スプラッシュ表示時間 ＜ 規定時間 の場合
				Log.i("MyApplication", "close splash " + (SPLASH_TIME - (splashEnd - splashStart)) + " msec later");

				// 規定時間まで待機
				new Handler().postDelayed(new Runnable() {
					public void run() {
						closeSplashImageInner();
		    		}
		        }, SPLASH_TIME - (splashEnd - splashStart));

			} else {
				// スプラッシュ表示時間 ≧ 規定時間 の場合
				closeSplashImageInner();
			}
		}
    }

    /**
	 * スプラッシュ画面を閉じる。内部関数。<br>
     */
    private synchronized void closeSplashImageInner() {
    	if (splashImage == null) {
    		return;
    	}

    	Log.d("MyApplication", "closeSplashImageInner()");
		splashImage.setVisibility(View.GONE);
		splashImage = null;
    }

	/**
	 * 体組成計のユーザメモリ書込開始アドレスを設定する。<br>
	 * @param  number : 選択されたユーザメモリ番号
	 * @return none
	 */
	public void setUserMemory(int number) {
		Log.i("MyApplication", "setUserMemory() number=" + number);

		switch (number) {
		case 1:
			mUserMemory = INFOADDR_COMPOSITIONMETER1;
			break;
		case 2:
			mUserMemory = INFOADDR_COMPOSITIONMETER2;
			break;
		case 3:
			mUserMemory = INFOADDR_COMPOSITIONMETER3;
			break;
		case 4:
			mUserMemory = INFOADDR_COMPOSITIONMETER4;
			break;
	    default:
			mUserMemory = INFOADDR_COMPOSITIONMETER1;
			break;
		}
	}

    /**
	 * 標準ブラウザでエネマネ画面を開く<br>
	 * @return none
	 */
    public void openEnemane(String url) {
		Log.i("MyApplication", "openEnemane");

    	Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
    	//CHG-ST:TF-#5622 2012/11/13 (山形)
    	try {
    		startActivity(intent);
    	} catch	(Exception e) {
    		Log.e("MyApplication", "Exception: " + e);
    		e.printStackTrace();
    		// ブラウザの起動に失敗した場合
    		String message = "ブラウザが起動できませんでした";
    		Toast.makeText(this, message, Toast.LENGTH_LONG).show();
    	}
    	//CHG-ED:TF-#5622 2012/11/13 (山形)
		return;
    }

	/**
	 * P.Uを表示する
	 *
	 * @param message 表示する文字列
	 * @param existButton キャンセルボタンを表示するかのフラグ<br>
	 *                    true:表示, false:非表示
	 * @param fontinfo フォントサイズ
	 */
	public void showPUDialog(final String message, final boolean existButton, final int fontinfo) {
		//Log.i("MyApplication", "showPUDialog");
		float font = (float)fontinfo;

		if(font == 0) {
			font = 24.f;
		}
		//端末の画面情報
		WindowManager wManager = (WindowManager)getSystemService(WINDOW_SERVICE);
		Display disp = wManager.getDefaultDisplay();

		int windowWidth = disp.getWidth();
		int windowHeight = disp.getHeight();

		if(pd == null) {
			pd = new Dialog(wv.getContext());
			pd.requestWindowFeature(Window.FEATURE_NO_TITLE);
			pd.setContentView(R.layout.custom_progress_dialog);

			LinearLayout linear2 = (LinearLayout)pd.findViewById(R.id.LinearLayout02);
			LayoutParams underParam = new LinearLayout.LayoutParams((int)(windowWidth * 0.9), (int)(windowHeight * 0.7));
			linear2.setLayoutParams(underParam);

			//表示文字列
			TextView text = (TextView)pd.findViewById(R.id.textView1);
			text.setTextSize(font);
			if(message != null) {
				text.setText(message);
			}

			//アイコン
			ImageView image = (ImageView)pd.findViewById(R.id.ImageView01);
			anim = (AnimationDrawable)image.getBackground();
			image.post(new Runnable() {
				@Override
				public void run() {
					anim.start();
				}
			});

			//キャンセルボタン
			Button button = (Button) pd.findViewById(R.id.button1);
			button.setTextSize(font);
			LinearLayout.LayoutParams bParam = new LinearLayout.LayoutParams((int)(windowWidth * 0.81), (int)(windowHeight * 0.1));
			button.setLayoutParams(bParam);
			button.setFocusable(false);
			button.setFocusableInTouchMode(false);
			button.setOnClickListener(new OnClickListener() {
				public void onClick(View v) {
					Log.i("MyApplication", "Clicked Cancel Button!!");
					jsB.cancelPUDialog();
					pd.dismiss();
					pd = null;
					if(anim != null) {
						anim.stop();
					}
				}
			});
			if(existButton == false) {
				button.setVisibility(View.INVISIBLE);
			}
			/* 2012.4.16時点でBackキー押下でダイアログ終了(必要であれば当該箇所のコメントアウトを無効化する)
			pd.setOnKeyListener(new OnKeyListener() {
				@Override
				public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
					if (KeyEvent.KEYCODE_BACK == keyCode) {
						//何も処理しない
						return true;
					}
					return false;
				}
			});
			*/
			pd.show();
		}
	}

	/**
	 * P.Uダイアログを閉じる
	 */
	public void closePUDialog() {
		if(pd != null && pd.isShowing() == true) {
			//Log.i("MyApplication", "Close P.U Dialog");
			if(anim != null) {
				anim.stop();
			}
			pd.dismiss();
			pd = null;
		}
	}

	/**
	 * 初回起動フラグを設定する<br>
	 * （JS→Main）<br>
	 * @param  初回起動フラグ
	 * @return none
	 */
	public void setFirstExe(boolean isFirstExe) {
		Log.i("MyApplication", "setFirstExe() isFirstExe=" + isFirstExe);
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		SharedPreferences.Editor editor = prefs.edit();
		editor.putBoolean("common.isFirstExe", isFirstExe);
		editor.commit();
	}

	/**
	 * 初回起動フラグを取得する<br>
	 * （JS→Main）<br>
	 * @param  none
	 * @return 初回起動フラグ(true/false)
	 */
	public boolean getFirstExe() {
		Log.i("MyApplication", "getFirstExe()");
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		return prefs.getBoolean("common.isFirstExe", true);
	}

	/**
	 * ローカルストレージをPreferenceへバックアップする<br>
	 * （JS→Main）<br>
	 * @param  name ストレージのKey名
	 * @param  key メンバ変数名
	 * @paran  value 保存する値
	 * @return none
	 */
	public void setPreference(String key, String value) {
		Log.i("MyApplication", "setPreference(" + key + "," + value + ")");
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		SharedPreferences.Editor editor = prefs.edit();
		// 受け取った"name.key"をキーに、valueを値としてpreferenceへ保存する
		editor.putString(key, value);
		editor.commit();
	}

	/**
	 * Preferenceのバックアップからローカルストレージを取得する<br>
	 * （JS→Main）<br>
	 * @param  key ローカルストレージのKey名
	 * @return value ローカルストレージの値（JSON文字列)
	 */
	public String getPreference(String key) {
		Log.i("MyApplication", "getPreference(" + key + ")");
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		return prefs.getString(key, "undefined");
	}

	/**
	 * Preferenceのバックアップからローカルストレージを削除する<br>
	 * （JS→Main）<br>
	 * @param  key ローカルストレージのKey名
	 * @return none
	 */
	public void deletePreference(String key) {
		Log.i("MyApplication", "deletePreference(" + key + ")");
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		SharedPreferences.Editor editor = prefs.edit();
		editor.remove(key);
		editor.commit();
	}

	/**
	 * Preferenceのバックアップを全削除する<br>
	 * （JS→Main）<br>
	 * @param  none
	 * @return none
	 */
	public void clearPreference() {
		Log.i("MyApplication", "clearPreference()");
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
		SharedPreferences.Editor editor = prefs.edit();
		editor.clear();
		editor.commit();
	}

	/**
	 * 洗濯機の予約設定ありタッチ画面用フラグの値を取得
     * TF-#2516 対応(2012/06/14 長坂)
	 * （Main→JS）
	 * @param  none
	 * @return value 洗濯機の予約設定ありタッチ画面用フラグの値（文字列)
	 */
	public String getWhTimerUseFlag() {
		Log.i("MyApplication", "getWhTimerUseFlag()");
		return whTimerUseFlag;
	}

	/**
	 * 洗濯機の予約設定ありタッチ画面用フラグの値を設定
     * TF-#2516 対応(2012/06/14 長坂)
	 * （JS→Main）
	 * @param  洗濯機の予約設定ありタッチ画面用フラグの値（文字列)
	 * @return none
	 */
	public void setWhTimerUseFlag(String val) {
		Log.i("MyApplication", "setWhTimerUseFlag() val= " + val);
		whTimerUseFlag = val;
	}

	/**
     * TF-#1915 検証NG対応(ProgressDialogの処理) (2012/07/04 原)
     * JS→Main）
     */
	public void setProgressDialogFlag(boolean mode) {
		Log.i("MyApplication", "setProgressDialogFlag() mode= " + mode);
		progressDialogFlag = mode;
	}

	/**
     * supportApplicationMenuFlgを設定する。
     */
	synchronized public void setSupportApplicationMenuFlg(boolean supportApplicationMenuFlg) {
		this.supportApplicationMenuFlg = supportApplicationMenuFlg;
	}

	@Override
	protected void onUserLeaveHint() {
		Log.i("MyApplication", "onUserLeaveHint()");
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONUSERLEAVEHINT);
		super.onUserLeaveHint();
	}

	/* TF-#2917で投入したJSエラーが発生した際の遷移処理 */
	/**
     * Javascript実行エラー系のローカル画面を読込む。
     */
	private void loadJsErrorUrl(String systemErrorCode) {
    	// 画面を消去
		wv.stopLoading();
		wv.clearView();

		loadErrUrl(
				systemErrorCode,
				ERROR_INFO.get(systemErrorCode).get("ERR_MESSAGE"),
				ERROR_INFO.get(systemErrorCode).get("BTN_NAME")
		);
	}


// delegate環境では、実行しないようにするため。trueに差し替える。
private boolean DELEGATE_FLAG = false;

	/* TF-#2917で投入したwindow.onErrorの内容通知処理 */
	/**
	 * Javascriptエラー時のメッセージをキャッチする。<br>
	 * （JS→Main）<br>
	 * @param  none
	 * @return none
	 */
	synchronized public void jsWindowOnError(String type, String arg1, String arg2, String arg3) {

		// delegate環境では、実行しないようにするため。
		if (DELEGATE_FLAG == true) {
			return ;
		}

		Log.d("MyApplication", "jsWindowOnError()");

		// TODO 暫定対応 TF-#2917
		// ページ読み込み中の場合だけエラー画面へ遷移させる。
		if (isPageLoading != true) {
			return ;
		}

		if (isJsError) {
			// isJsError:trueの場合は
			// 既にWebViewに対してなんらかのエラー画面遷移処理を命じ、実行待ち状態であるはずなので待機する。
			Log.d("MyApplication", "ErrorPage is loading. This error ignored");
		} else {
			// キャッシュをクリアする(TF-#8917,TF-#8980)
			wv.clearCache(true);
			Log.d("MyApplication", "cache is cleared.");

			if (type.equals("object")) {
				// ローカル画面読込処理をwebviewに対して要求する。
				// (処理中のWebViewスレッドに対する呼びだしになるので、直にWebViewのメソッドを実行しない)
				wv.getHandler().post(new Runnable() {
					public void run() {
						loadJsErrorUrl(SYSTEM_ERR_CODE_G_11292_30004);
					}
				});
			} else {
				// ローカル画面読込処理をwebviewに対して要求する。
				// (処理中のWebViewスレッドに対する呼びだしになるので、直にWebViewのメソッドを実行しない)
				wv.getHandler().post(new Runnable() {
					public void run() {
						loadJsErrorUrl(SYSTEM_ERR_CODE_G_11292_30104);
					}
				});
			}
		}

		// ページ読み込み中の場合、
		if (isPageLoading) {

			// 最初のエラー以外は無視する。
			// これがisJsError = trueになった場合は、画面遷移が走るはずなので、直後にonPageStartedが走り、そのタイミングでフラグリセットすることを前提として処理する。
			// 当前提が崩れる場合は、当フラグの制御を再検討すること。
			isJsError = true;
		}
	}


	@Override
	protected void onStart() {
		Log.i("MyApplication", "onStart()");
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONSTART);
		super.onStart();
	}

	@Override
	protected void onRestart() {
		Log.i("MyApplication", "onRestart()");
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONRESTART);
		super.onRestart();
	}

	@Override
	protected void onStop() {
		Log.i("MyApplication", "onStop()");
		// アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONSTOP);
		super.onStop();
        // アプリログの一時退避
        Log.backupAppLog();

// ADD-ST [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある
        // onStop時(アクティビティ非表示)、次回onResumeでVERSION_FILEファイル取得する
        requiredVersionFile = true;
// ADD-ED [欠陥管理 TF-#14536]【機種依存】NFCでタッチ時に、システムエラーとなることがある
	}

	@Override
	public void onLowMemory() {
		Log.i("MyApplication", "onLowMemory()");
        // アプリ状態を更新
		asi.saveState(ApplicationStateInfo.STATE_ONLOWMEMORY);
		super.onLowMemory();
	}

    @Override
    public void finish() {
        Log.i("MyApplication", "finish()");
        // アプリ状態を更新
        asi.saveState(ApplicationStateInfo.STATE_USER_FINISH);
        super.finish();
    }

	/* TF-#2579(PAD-#7666)で追加 */
	/**
	 * NFC ポーリングタイマーを開始する。<br>
	 * @param  none
	 * @return none
	 */
	public void startNfcPollingTimer(int timeoutSec) {
		Log.i("MyApplication", "startNfcPollingTimer()");

		isNfcPolling = true;
		lastTimeoutSec = timeoutSec;

		// ポーリング停止状態ではない場合は、ポーリングタイムアウトタイマーの開始を試みる。
		if (!isPoolingPaused) {
			nfcPollingTimerStart(timeoutSec);
		}
	}

	/* TF-#2579(PAD-#7666)で追加 */
	/**
	 * NFC ポーリングタイマーを再開する。<br>
	 * （一度はstartNfcPollingTimerが行われている前提）
	 * @param  none
	 * @return none
	 */
	public void resumeNfcPollingTimer(){
		// ポーリング中断中の場合は、ポーリングを再開する。
		if (isNfcPolling) {
			Log.d("MyApplication", "resumeNfcPollingTimer start");
			int timeoutSec = lastTimeoutSec;
			nfcPollingTimerStart(timeoutSec);
		}
	}

	/* TF-#2579(PAD-#7666)で追加 */
	/**
	 * NFC ポーリングタイマーを一時停止する。<br>
	 * （Main→JsBridge）<br>
	 * @param  none
	 * @return none
	 */
	public void pauseNfcPollingTimer() {
		Log.d("MyApplication", "pauseNfcPollingTimer()");

		if (mNfcPollingTimer != null) {
			mNfcPollingTimer.cancel();
			mNfcPollingTimer = null;
		}
	}

	/* TF-#2579(PAD-#7666)で追加 */
	/**
	 * NFC ポーリングタイマーを停止する。<br>
	 * （Main→JsBridge）<br>
	 * @param  none
	 * @return none
	 */
	public void stopNfcPollingTimer() {
		Log.d("MyApplication", "stopNfcPollingTimer()");

		isNfcPolling = false;
		if (mNfcPollingTimer != null) {
			mNfcPollingTimer.cancel();
			mNfcPollingTimer = null;
		}
	}

	/* TF-#2579(PAD-#7666)で追加 */
	/**
	 * NFC ポーリングタイマーを起動する。<br>
	 * @param  none
	 * @return none
	 */
	private void nfcPollingTimerStart(int timeoutSec){
		Log.d("MyApplication", "nfcPollingTimer start");
		if (mNfcPollingTimer == null) {
			mNfcPollingTimer = new Timer(true);

			mNfcPollingTimer.schedule( new TimerTask() {
				@Override
				public void run() {
					mNfcPollingHandler.post( new Runnable() {
						public void run() {
							// タイムアウト処理
							isNfcPolling = false;
							Log.d("MyApplication", "nfcPollingTimer timeout");
							onErrorPolling(ERR_ID_NFC_POLLING_TIMEOUT);
						}
					});
				}
			}, timeoutSec * 1000);	// 2012/08/27 #4806対応 modified
		}
	}

	// 2012/09/12 #5017 アプリ同時起動対応 add start
	@Override
	public void onFelicaPollingResultReceived(int resultCode) {
		Log.i("MyApplication", "onFelicaPollingResultReceived() resultCode=" + resultCode);
		if (resultCode == nfcWrapper.RES_SUCCESS) {
			Log.d("MyApplication","StartApp#BroadcastReceiver#onReceive : Polling Success");
			// タグ取得完了を通知する
	    	jsB.notifyNfcReady();   // とりあえず

			// リードライト処理スレッド化
	    	startReadWriteNfcThread();

		} else {
			switch (resultCode) {
			case nfcWrapper.RES_SUCCESS_NFC_AVAILABLE:
			case nfcWrapper.RES_SUCCESS_FELICA_AVAILABLE:
				Log.d("PAD","--- NFC or Felica resultCode =" + resultCode);
				mTouchStat = TOUCH_OK;
		    	// 2012/08/02 #4177対応 add start
				if (mCheckTouchStat) {
					mCheckTouchStat = false;
					// タイムアウト設定
					nfcW.setPollingTimeout(mTimeoutSec);
					// isPoolingPauseがtrueの場合は、初期化のみ行い、nfcW.enableNfcは呼び出さない。
					if (!isPoolingPaused) {
						// Felica接続処理
						touchFromCheckTouchStat();
					} else {
						Log.d("MyApplication", "StartApp#BroadcastReceiver#onReceive : main Activity is pausing.");
					}
				}
		    	// 2012/08/02 #4177対応 add end
				break;
			case nfcWrapper.RES_ERROR_NFC_DISABLED:		// 2012/08/21 #4487対応 add
				Log.d("PAD","--- NFC Disable resultCode =" + resultCode);
				mTouchStat = resultCode;
				if (isEnableNfc != DISABLE_NFC) {
					onErrorPolling(resultCode);
				}
				break;
			case nfcWrapper.RES_ERROR_NFC_NOT_EQUIPPED:
				Log.d("PAD","--- NFC Felica not Equipped resultCode =" + resultCode);
				mTouchStat = TOUCH_NG;
				break;
			case nfcWrapper.RES_ERROR_FELICA_NOT_INITIALIZED:
			case nfcWrapper.RES_ERROR_FELICA_OPEN_FAILED:
			case nfcWrapper.RES_ERROR_FELICA_LOCKED:
				Log.d("PAD","--- Felica init Error  resultCode =" + resultCode);
				mTouchStat = resultCode;
				if (isEnableNfc != DISABLE_NFC) {
					onErrorPolling(resultCode);
				}
				break;
		    default:
				// Polling失敗時の処理を記載
				Log.d("PAD","--- Polling faild!  resultCode =" + resultCode);
				onErrorPolling(resultCode);
			}
		}
	}
	// 2012/09/12 #5017 アプリ同時起動対応 add end

	// ADD-ST:TF-#7100(脆弱性対策) 2012/12/21 k.ohtani
	public void privateBroadcastReciverProc(Context context, Intent intent) {
		if (mWaitDialog != null && mWaitDialog.isShowing()) {
			// WebViewロード中：ロード完了後に表示するためにIntentを保存
			Log.d("MyApplication", "Postpone showing dialog, as loading is proceeding.");
			mNotifyUpdatePendingIntent = new Intent(intent);
		} else {
			// WebView非ロード中：ダイアログを即時表示
	    	Log.d("MyApplication", "Show dialog for notifying update.");

	    	// キャッシュクリア
	    	// #7591 アプリトップのWebAPIキャッシュ化対応 (2012/07/10 NID小林)
			// #12709 Blank画面へ遷移後、WebAPIキャッシュクリアできないので、JSへ移行
	    	//jsB.clearApiCache(wv.getUrl());
			wv.clearCache(true);

			// FeliCa／NFCは停止
			disableNfc();

			// ダイアログ表示(二重起動はしない)
			if (mVupNotifyDialog == null || !mVupNotifyDialog.isShowing()) {
				final boolean forAppUpdate = intent.getBooleanExtra("forAppUpdate", false);
				final String url = intent.getStringExtra("url");

			    // ダイアログ表示
				AlertDialog.Builder builder = new AlertDialog.Builder(context);
				builder.setCancelable(false); // BACKキー無効
				builder.setOnKeyListener(new DialogInterface.OnKeyListener() {
					@Override
					public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
						// Disable Search key
						if (keyCode == KeyEvent.KEYCODE_SEARCH) {
							return true;
						}
						return false;
					}
				});
				builder.setIcon(android.R.drawable.ic_dialog_info);
				builder.setTitle(intent.getStringExtra("title"));
				builder.setMessage(intent.getStringExtra("message"));
				builder.setPositiveButton(intent.getStringExtra("button"), new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface di, int whichButton) {
						if (forAppUpdate) {
							// 指定アプリ(Google Play等)を起動
							Uri uri = Uri.parse(url);
							Log.d("MyApplication", "Launch uri=" + uri);
							Intent it = new Intent(Intent.ACTION_VIEW, uri);
							startActivity(it);
							// アプリ終了
							finish();
						} else {
							// 指定URLへ遷移
// CHG-ST #19492:【アイコン強調表示】Android(新UX)　10/15以降のアプリインストール状態で、バージョンアップ(js,マスタ更新)発生し、アプリ起動すると、機器一覧画面が表示される。(「キッチンポケット」にはNEW表示されている) PSDCD肖 2014-09-28
							Log.d("MyApplication", "old url=" + url);
							final String newUrl;
							if (url.endsWith("gmcotp002.html")) {
								if (jsB.isShortcutsUiEnabled()) {
									newUrl = url.replace("gmcotp002.html", "shortcut.html?goto=SCUXPORTAL&usecase_id=SYS_COM_UXPORTAL_01_001");
								}else {
									newUrl = url.replace("gmcotp002.html", "gmcotp003.html?serviceUpdate=true");
								}
							} else {
								newUrl = url;
							}
							Log.d("MyApplication", " new url=" + newUrl);
		    				wv.loadUrl(newUrl);
// CHG-ED #19492:【アイコン強調表示】Android(新UX)　10/15以降のアプリインストール状態で、バージョンアップ(js,マスタ更新)発生し、アプリ起動すると、機器一覧画面が表示される。(「キッチンポケット」にはNEW表示されている) PSDCD肖 2014-09-28
							// リロードの場合読み込み中ダイアログが表示されないのでここで表示
							// TF-#3529 WebApi呼び出し中で読み込み中表示対応 2012/07/10 張
		    				openProgressDialogInner();

							// レスポンスがない場合、タイムアウトする対応
							if (mRespTimer == null) {
								mRespTimer = new Timer(true);
								mRespTimer.schedule( new TimerTask() {
									@Override
									public void run() {
										mRespHandler.post( new Runnable() {
											public void run() {
												// タイムアウト処理
												closeProgressDialog();
												loadErrUrl(
													SYSTEM_ERR_CODE_G_11292_30002,
													ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("ERR_MESSAGE"),
													ERROR_INFO.get(SYSTEM_ERR_CODE_G_11292_30002).get("BTN_NAME")
												);
											}
										});
									}
								}, RESPONSE_TIMEOUT);
							}
						}
					}
				});
				mVupNotifyDialog = builder.create();

				// 2012/09/03 #5011対応 add start
		    	mVupNotifyDialog.setOnShowListener(new DialogInterface.OnShowListener(){
					@Override
					public void onShow(DialogInterface dialog) {
						Button btnPositive = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_POSITIVE);
						if (btnPositive != null) {
							final int WC = LinearLayout.LayoutParams.WRAP_CONTENT;
							final int FP = LinearLayout.LayoutParams.WRAP_CONTENT;
							final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WC, FP, 1);
							btnPositive.setLayoutParams(layoutParams);
							btnPositive.setSingleLine();
						}
					}
				});
				// 2012/09/03 #5011対応 add end
				mVupNotifyDialog.show();
			} else {
				Log.d("MyApplication", "VUP dialog is already shown!");
			}
		}
	}
	// ADD-ED:TF-#7100(脆弱性対策) 2012/12/21 k.ohtani

	/**
	 * 動作モードフラグをチェックする。<br>
	 * @param  param : 動作モードフラグ
	 * @return 動作モード設定（"true": 設定済、"false": 未設定）
	 */
    public String getParam(String param) {
		String result = "false";
		// 動作モード
		//Log.d("MyApplication", "getParam() MODE_FLAG_LIST=" + MODE_FLAG_LIST);
		for (String item : MODE_FLAG_LIST.keySet()) {
			//Log.d("MyApplication", "getParam() item=" + item);
			if (item.equals(param)) {
				// 動作フラグが定義されている場合
				//Log.d("MyApplication", "getParam() flag is found");
				result = MODE_FLAG_LIST.get(item).get(0);
				break;
        }
        }
		return result;
    }

	/**
	 * 動作モードフラグを設定する。<br>
	 * @param  key   : 動作モードフラグ
	 * @param  value : 設定値
	 * @return none
	 */
	public void setParam(String key, String value) {
		// 動作モード
		Log.d("MyApplication", "setParam() MODE_FLAG_LIST=" + MODE_FLAG_LIST);
		for (String item : MODE_FLAG_LIST.keySet()) {
			Log.d("MyApplication", "setParam() item=" + item);
			if (item.equals(key)) {
				// 動作フラグが定義されている場合
				Log.d("MyApplication", "setParam() flag is found");
				MODE_FLAG_LIST.get(item).set(0, value);
				DebugInfo.getInstance().setDebugInfo("動作フラグ(Java)", MODE_FLAG_LIST.get(item).get(1), MODE_FLAG_LIST.get(item).get(0));	//DEL@PROD
				break;
			}
		}
	}
																										//DEL@PROD
// Digest認証＆Basic認証－入力ダイアログ表示版 start													//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】GeminiSTG、クラパナSTG向けの認証情報（SharedPreferences）の設定状態を判定する。<br>	//DEL@PROD
	 * @param  none																						//DEL@PROD
	 * @return 設定状態（true: 設定済、false: 未設定）													//DEL@PROD
	 */																									//DEL@PROD
	private boolean checkHttpAuthTbl() {																//DEL@PROD
		Log.i("MyApplication", "checkHttpAuthTbl()");													//DEL@PROD
																										//DEL@PROD
		if ((getPreference(STG_AUTH_HOST) != "undefined") &&											//DEL@PROD
			(getPreference(CP1_AUTH_HOST) != "undefined") &&											//DEL@PROD
			(getPreference(CP2_AUTH_HOST) != "undefined")) {											//DEL@PROD
			return true;																				//DEL@PROD
		} else {																						//DEL@PROD
			return false;																				//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】GeminiSTG向けの認証情報（SharedPreferences）を設定する。<br>							//DEL@PROD
	 * @param  host: ホスト名（例: smartlife.stg.panasonic.co.jp:80）									//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTblForGemini(final String host) {											//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTblForGemini()");											//DEL@PROD
																										//DEL@PROD
		JSONObject jsonAuth = new JSONObject();															//DEL@PROD
		try {																							//DEL@PROD
			jsonAuth.put("id", USERNAME);																//DEL@PROD
			jsonAuth.put("pw", PASSWORD);																//DEL@PROD
			String jsonStr = jsonAuth.toString();														//DEL@PROD
			setPreference(host, jsonStr);																//DEL@PROD
		} catch (JSONException e) {																		//DEL@PROD
			Log.e("MyApplication", "JSONException: " + e);												//DEL@PROD
			e.printStackTrace();																		//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】Gemini-PrevSTG向けの認証情報（SharedPreferences）を設定する。<br>					//DEL@PROD
	 * @param  host: ホスト名（例: prev.smartlife.stg.panasonic.co.jp:80）								//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTblForGeminiPrev(final String host) {										//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTblForGeminiPrev()");										//DEL@PROD
																										//DEL@PROD
		JSONObject jsonAuth = new JSONObject();															//DEL@PROD
		try {																							//DEL@PROD
			jsonAuth.put("id", USERNAME);																//DEL@PROD
			jsonAuth.put("pw", PASSWORD);																//DEL@PROD
			String jsonStr = jsonAuth.toString();														//DEL@PROD
			setPreference(host, jsonStr);																//DEL@PROD
		} catch (JSONException e) {																		//DEL@PROD
			Log.e("MyApplication", "JSONException: " + e);												//DEL@PROD
			e.printStackTrace();																		//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】クラパナ向けの認証情報（SharedPreferences）を設定する。<br>							//DEL@PROD
	 * @param  host: ホスト名（例: smartlife.stg.panasonic.co.jp:80）									//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTblForCp(final String host) {												//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTblForCp()");												//DEL@PROD
																										//DEL@PROD
		JSONObject jsonAuth = new JSONObject();															//DEL@PROD
		try {																							//DEL@PROD
			jsonAuth.put("id", CP_USERNAME);															//DEL@PROD
			jsonAuth.put("pw", CP_PASSWORD);															//DEL@PROD
			String jsonStr = jsonAuth.toString();														//DEL@PROD
			setPreference(host, jsonStr);																//DEL@PROD
		} catch (JSONException e) {																		//DEL@PROD
			Log.e("MyApplication", "JSONException: " + e);												//DEL@PROD
			e.printStackTrace();																		//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】GeminiSTG、クラパナSTG向けの認証情報（SharedPreferences）に初期値を設定する。<br>	//DEL@PROD
	 * 本メソッドは、インストール直後のアプリ初回起動やデータ消去時に実行する。<br>						//DEL@PROD
	 * @param  none																						//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void InitHttpAuthTbl() {																	//DEL@PROD
		Log.i("MyApplication", "InitHttpAuthTbl()");													//DEL@PROD
																										//DEL@PROD
		// GeminiSTG向け																				//DEL@PROD
		setHttpAuthTblForGemini(STG_AUTH_HOST);															//DEL@PROD
		setHttpAuthTblForGemini(STG1_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG1_AUTH_HOST_PORT2);													//DEL@PROD
		setHttpAuthTblForGemini(STG2_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG2_AUTH_HOST_PORT2);													//DEL@PROD
		setHttpAuthTblForGemini(STG3_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG3_AUTH_HOST_PORT2);													//DEL@PROD
		setHttpAuthTblForGemini(STG4_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG4_AUTH_HOST_PORT2);													//DEL@PROD
		setHttpAuthTblForGemini(STG5_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG5_AUTH_HOST_PORT2);													//DEL@PROD
		setHttpAuthTblForGemini(STG6_AUTH_HOST_PORT1);													//DEL@PROD
		setHttpAuthTblForGemini(STG6_AUTH_HOST_PORT2);													//DEL@PROD
		// ADD-ST [仕様変更作業管理 TF-#24017] MarsFlag移行：本線化対応										//DEL@PROD
		setHttpAuthTblForGemini(STG1_SOLR_AUTH_HOST_PORT1);							//DEL@PROD
		setHttpAuthTblForGemini(STG5_SOLR_AUTH_HOST_PORT1);								//DEL@PROD
		// ADD-ED [仕様変更作業管理 TF-#24017] MarsFlag移行：本線化対応										//DEL@PROD
																										//DEL@PROD
		// Gemini-Prev向け																				//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_AUTH_HOST);													//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_AUTH_HOST_PORT1);												//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_AUTH_HOST_PORT2);												//DEL@PROD
																										//DEL@PROD
		// Gemini-PrevSTG向け																			//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG_AUTH_HOST);												//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG1_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG1_AUTH_HOST_PORT2);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG2_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG2_AUTH_HOST_PORT2);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG3_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG3_AUTH_HOST_PORT2);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG4_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG4_AUTH_HOST_PORT2);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG5_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG5_AUTH_HOST_PORT2);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG6_AUTH_HOST_PORT1);											//DEL@PROD
		setHttpAuthTblForGeminiPrev(PREV_STG6_AUTH_HOST_PORT2);											//DEL@PROD
																										//DEL@PROD
		// クラパナSTG向け																				//DEL@PROD
		setHttpAuthTblForCp(CP1_AUTH_HOST);																//DEL@PROD
		setHttpAuthTblForCp(CP1_AUTH_HOST_PORT1);														//DEL@PROD
		setHttpAuthTblForCp(CP1_AUTH_HOST_PORT2);														//DEL@PROD
		setHttpAuthTblForCp(CP2_AUTH_HOST);																//DEL@PROD
		setHttpAuthTblForCp(CP2_AUTH_HOST_PORT1);														//DEL@PROD
		setHttpAuthTblForCp(CP2_AUTH_HOST_PORT2);														//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】GeminiSTG、クラパナSTG向けの認証情報（SharedPreferences）よりアカウント情報を取得する。<br>	//DEL@PROD
	 * 【HTTP認証】取得したアカウント情報をsetHttpAuthUsernamePasswordへ設定する。<br>					//DEL@PROD
	 * @param  none																						//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTblSub(String host, String realm) {											//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTblSub()");													//DEL@PROD
																										//DEL@PROD
		JSONObject jsonObj;																				//DEL@PROD
		String idStr = "";																				//DEL@PROD
		String pwStr = "";																				//DEL@PROD
																										//DEL@PROD
		try {																							//DEL@PROD
			String val = getPreference(host);															//DEL@PROD
			if (val == "undefined") {																	//DEL@PROD
				// STGサーバ以外が設定されている場合													//DEL@PROD
				Log.d("MyApplication", "host is not GeminiSTG or CPSTG");								//DEL@PROD
				return;																					//DEL@PROD
			}																							//DEL@PROD
			jsonObj = new JSONObject(val);																//DEL@PROD
			if (jsonObj.has("id")) {																	//DEL@PROD
				idStr = jsonObj.getString("id");														//DEL@PROD
			}																							//DEL@PROD
			if (jsonObj.has("pw")) {																	//DEL@PROD
				pwStr = jsonObj.getString("pw");														//DEL@PROD
			}																							//DEL@PROD
			wv.setHttpAuthUsernamePassword(host, realm, idStr, pwStr);									//DEL@PROD
																										//DEL@PROD
		} catch (JSONException e) {																		//DEL@PROD
			Log.e("MyApplication", "JSONException: " + e);												//DEL@PROD
			e.printStackTrace();																		//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】GeminiSTG、クラパナSTG向けの認証情報（SharedPreferences）をsetHttpAuthUsernamePasswordへ設定する。<br>	//DEL@PROD
	 * @param  none																						//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTbl() {																		//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTbl()");														//DEL@PROD
																										//DEL@PROD
		// GeminiSTG向け																				//DEL@PROD
		setHttpAuthTblSub(AUTH_HOST, REALM);				//ホスト名のみ								//DEL@PROD
		setHttpAuthTblSub(AUTH_HOST_PORT1, REALM);			//ホスト名＋https							//DEL@PROD
		setHttpAuthTblSub(AUTH_HOST_PORT2, REALM);			//ホスト名＋http							//DEL@PROD
																										//DEL@PROD
		// クラパナSTG向け																				//DEL@PROD
		setHttpAuthTblSub(CP1_AUTH_HOST, CP_REALM);			//ホスト名のみ								//DEL@PROD
		setHttpAuthTblSub(CP1_AUTH_HOST_PORT1, CP_REALM);	//ホスト名＋https							//DEL@PROD
		setHttpAuthTblSub(CP1_AUTH_HOST_PORT2, CP_REALM);	//ホスト名＋http							//DEL@PROD
																										//DEL@PROD
		setHttpAuthTblSub(CP2_AUTH_HOST, CP_REALM);			//ホスト名のみ								//DEL@PROD
		setHttpAuthTblSub(CP2_AUTH_HOST_PORT1, CP_REALM);	//ホスト名＋https							//DEL@PROD
		setHttpAuthTblSub(CP2_AUTH_HOST_PORT2, CP_REALM);	//ホスト名＋http							//DEL@PROD
	}																									//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】ユーザ入力された認証情報（SharedPreferences）を設定する。<br>						//DEL@PROD
	 * @param  host: ホスト名（例: smartlife.stg.panasonic.co.jp:80）									//DEL@PROD
	 * @param  id: ユーザ																				//DEL@PROD
	 * @param  pw: パスワード																			//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void setHttpAuthTblFormInputDialog(final String host, final String id, final String pw) {	//DEL@PROD
		Log.i("MyApplication", "setHttpAuthTblFormInputDialog()");										//DEL@PROD
																										//DEL@PROD
		JSONObject jsonAuth = new JSONObject();															//DEL@PROD
		try {																							//DEL@PROD
			jsonAuth.put("id", id);																		//DEL@PROD
			jsonAuth.put("pw", pw);																		//DEL@PROD
			String jsonStr = jsonAuth.toString();														//DEL@PROD
			setPreference(host, jsonStr);																//DEL@PROD
		} catch (JSONException e) {																		//DEL@PROD
			Log.e("MyApplication", "JSONException: " + e);												//DEL@PROD
			e.printStackTrace();																		//DEL@PROD
		}																								//DEL@PROD
	}																									//DEL@PROD
        																								//DEL@PROD
	/**																									//DEL@PROD
	 * 【HTTP認証】Digest認証＆Basic認証向けの認証入力ダイアログを表示する。<br>						//DEL@PROD
	 * @param  handler: HttpAuthHandler																	//DEL@PROD
	 * @param  host: ホスト名（例: smartlife.stg.panasonic.co.jp:80）									//DEL@PROD
	 * @param  realm: 認証レルム																		//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void showHttpAuthDialog(final HttpAuthHandler handler, final String host, final String realm) {	//DEL@PROD
		Log.i("MyApplication", "showHttpAuthDialog()");													//DEL@PROD
		Log.d("MyApplication", "host = " + host + ", realm = " + realm);								//DEL@PROD
																										//DEL@PROD
		// LayoutInflaterインスタンス生成																//DEL@PROD
		LayoutInflater factory = LayoutInflater.from(this);												//DEL@PROD
		final View textSigninView = factory.inflate(R.layout.dialog_httpauth, null);					//DEL@PROD
																										//DEL@PROD
		// AlertDoalog.Builderインスタンス生成															//DEL@PROD
		AlertDialog.Builder builder = new AlertDialog.Builder(this);									//DEL@PROD
																										//DEL@PROD
		// InfalterメソッドでViewインスタンス(dialog_signin.xml)生成									//DEL@PROD
		// Dialogに生成したViewインスタンスをカスタムViewとして加える									//DEL@PROD
		builder.setView(textSigninView);																//DEL@PROD
																										//DEL@PROD
		// アイコン設定																					//DEL@PROD
		builder.setIcon(android.R.drawable.ic_dialog_info);												//DEL@PROD
		// タイトル設定																					//DEL@PROD
		builder.setTitle("認証が必要です");																//DEL@PROD
		// サーバ名設定																					//DEL@PROD
		TextView tvHostName = (TextView) textSigninView.findViewById(R.id.hostname);					//DEL@PROD
		tvHostName.setText(host);																		//DEL@PROD
																										//DEL@PROD
		// 認証情報（SharedPreferences）のID/PWを消去する												//DEL@PROD
		//setHttpAuthTblFormInputDialog(host, "", "");													//DEL@PROD
																										//DEL@PROD
		// Backキー、Searchキーの無効化（他のダイアログ表示仕様に合わせます）							//DEL@PROD
		builder.setCancelable(false);																	//DEL@PROD
		builder.setOnKeyListener(new DialogInterface.OnKeyListener() {									//DEL@PROD
			@Override																					//DEL@PROD
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {					//DEL@PROD
				// Disable Search key																	//DEL@PROD
				if (keyCode == KeyEvent.KEYCODE_SEARCH) {												//DEL@PROD
					return true;																		//DEL@PROD
				}																						//DEL@PROD
				return false;																			//DEL@PROD
			}																							//DEL@PROD
		});																								//DEL@PROD
																										//DEL@PROD
		// OKイベント																					//DEL@PROD
		builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {							//DEL@PROD
			public void onClick(DialogInterface dialog, int whichButton) {								//DEL@PROD
				Log.i("MyApplication", "showHttpAuthDialog() OK button clicked");						//DEL@PROD
																										//DEL@PROD
				EditText etUserName = (EditText) textSigninView.findViewById(R.id.username);			//DEL@PROD
				String userName = etUserName.getText().toString();										//DEL@PROD
				EditText etUserPass = (EditText) textSigninView.findViewById(R.id.password);			//DEL@PROD
				String userPass = etUserPass.getText().toString();										//DEL@PROD
																										//DEL@PROD
				Log.d("MyApplication", "userName = " + userName + ", userPass = " + userPass);			//DEL@PROD
																										//DEL@PROD
				// 認証情報（SharedPreferences）を設定する												//DEL@PROD
				setHttpAuthTblFormInputDialog(host, userName, userPass);								//DEL@PROD
																										//DEL@PROD
				// 認証情報（setHttpAuthUsernamePassword）を設定する									//DEL@PROD
				wv.setHttpAuthUsernamePassword(host, realm, userName, userPass);						//DEL@PROD
																										//DEL@PROD
				handler.proceed(userName, userPass);													//DEL@PROD
				mHttpAuthDialog.dismiss();																//DEL@PROD
				mHttpAuthDialog = null;																	//DEL@PROD
			}																							//DEL@PROD
		});																								//DEL@PROD
																										//DEL@PROD
		// Cancelイベント																				//DEL@PROD
		builder.setNegativeButton("キャンセル", new DialogInterface.OnClickListener() {					//DEL@PROD
			public void onClick(DialogInterface dialog, int whichButton) {								//DEL@PROD
				Log.i("MyApplication", "showHttpAuthDialog() Cancel button clicked");					//DEL@PROD
																										//DEL@PROD
				handler.cancel();																		//DEL@PROD
				mHttpAuthDialog.dismiss();																//DEL@PROD
				mHttpAuthDialog = null;																	//DEL@PROD
				// 認証エラーが表示されてしまうので、強制的にベース画面へ戻す							//DEL@PROD
				wv.goBack();																			//DEL@PROD
			}																							//DEL@PROD
		});																								//DEL@PROD
																										//DEL@PROD
		mHttpAuthDialog = builder.create();																//DEL@PROD
		mHttpAuthDialog.show();																			//DEL@PROD
    }																									//DEL@PROD
// Digest認証＆Basic認証－入力ダイアログ表示版 end														//DEL@PROD
																										//DEL@PROD
																										//DEL@PROD
	/**																									//DEL@PROD
	 * デバッグ情報ダイアログを表示する。<br>															//DEL@PROD
	 * @param  none																						//DEL@PROD
	 * @return none																						//DEL@PROD
	 */																									//DEL@PROD
	private void showDebugInfoDialog() {																//DEL@PROD
		Log.i("MyApplication", "showDebugInfoDialog()");												//DEL@PROD
																										//DEL@PROD
		// 登録されたカテゴリのリストを表示する															//DEL@PROD
		ArrayList<String> debugMenuList = DebugInfo.getInstance().getDebugMenu();						//DEL@PROD
		String[] items = new String[debugMenuList.size()];												//DEL@PROD
		for (int i = 0; i < debugMenuList.size(); i++) {												//DEL@PROD
			items[i] = debugMenuList.get(i);															//DEL@PROD
		}																								//DEL@PROD
		AlertDialog.Builder menuDialog = new AlertDialog.Builder(this);									//DEL@PROD
		menuDialog.setTitle("デバッグ情報");															//DEL@PROD
		menuDialog.setItems(																			//DEL@PROD
			items,																						//DEL@PROD
			new DialogInterface.OnClickListener() {														//DEL@PROD
				public void onClick(DialogInterface dialog, int which) {								//DEL@PROD
					// リスト内のカテゴリが選択された場合												//DEL@PROD
					Log.d("MyApplication", "onClick() ListNo=" + which);								//DEL@PROD
																										//DEL@PROD
					dialog.dismiss();																	//DEL@PROD
					AlertDialog.Builder infoDialog = new AlertDialog.Builder(StartApp.this);			//DEL@PROD
																										//DEL@PROD
					// 選択されたカテゴリの詳細情報を取得する											//DEL@PROD
					ArrayList<String> debugMenuList = DebugInfo.getInstance().getDebugMenu();			//DEL@PROD
					String category = debugMenuList.get(which);											//DEL@PROD
					infoDialog.setTitle(category);														//DEL@PROD
					String info = DebugInfo.getInstance().getDebugInfo(category);						//DEL@PROD
																										//DEL@PROD
					// 選択されたカテゴリの詳細情報を表示する											//DEL@PROD
					//infoDialog.setMessage(info).show();												//DEL@PROD
					TextView tView = new TextView(StartApp.this);										//DEL@PROD
					tView.setTextColor(Color.WHITE);													//DEL@PROD
					tView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14f);									//DEL@PROD
					tView.setText(info);																//DEL@PROD
					//infoDialog.setView(tView).show();													//DEL@PROD
					ScrollView sView = new ScrollView(StartApp.this);									//DEL@PROD
					sView.addView(tView);																//DEL@PROD
					infoDialog.setView(sView).show();													//DEL@PROD
				}																						//DEL@PROD
			});																							//DEL@PROD
		menuDialog.show();																				//DEL@PROD
	}																									//DEL@PROD

	/**
	 * デバッグ表示情報を登録する。<br>
	 * @param  none
	 * @return none
	 */
	private void setDebugInfo() {
		// 動作モード																					//DEL@PROD
		//Log.d("MyApplication", "setDebugInfo() MODE_FLAG_LIST=" + MODE_FLAG_LIST);					//DEL@PROD
		for (String item : MODE_FLAG_LIST.keySet()) {													//DEL@PROD
			//Log.d("MyApplication", "setDebugInfo() item=" + item);									//DEL@PROD
			if (MODE_FLAG_LIST.get(item).get(2) == "true") {											//DEL@PROD
				// デバッグ情報の表示が必要な場合														//DEL@PROD
				//Log.d("MyApplication", "setDebugInfo() flag is found");								//DEL@PROD
				DebugInfo.getInstance().setDebugInfo("動作フラグ(Java)", MODE_FLAG_LIST.get(item).get(1), MODE_FLAG_LIST.get(item).get(0));	//DEL@PROD
			}																							//DEL@PROD
		}																								//DEL@PROD
	}

// ADD-START TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17
	/**
	 * APサーバのHTTP/HTTPSポートの初期値を設定する<br>
	 * SharedPreferenceに前回設定値が保存されている場合にはその値を設定する
	 * そうでなければExternalServiceUtilクラスで定義されるデフォルト値を設定する
	 *
	 * デバッグ情報の更新もあわせて行なう
	 *
	 * @param  none
	 * @return none
	 */
	private void initApServerConf() {																	//DEL@PROD
		Log.i("MyApplication", "initApServerConf");														//DEL@PROD
																										//DEL@PROD
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);					//DEL@PROD
		final int httpPort	= prefs.getInt("ExternalServiceUtil.apServerHttpPort",	ExternalServiceUtil.AP_HTTP_PORT); //DEL@PROD
		final int httpsPort	= prefs.getInt("ExternalServiceUtil.apServerHttpsPort",	ExternalServiceUtil.AP_HTTPS_PORT);//DEL@PROD
																										//DEL@PROD
		ExternalServiceUtil.setApServerHttpPort(Integer.valueOf(httpPort));								//DEL@PROD
		ExternalServiceUtil.setApServerHttpsPort(Integer.valueOf(httpsPort));							//DEL@PROD
																										//DEL@PROD
		setApServerDebugInfo(httpPort, httpsPort);														//DEL@PROD
	}																									//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
	/**
	 * AP2サーバのHTTP/HTTPSポートの初期値を設定する<br>
	 * SharedPreferenceに前回設定値が保存されている場合にはその値を設定する
	 * そうでなければExternalServiceUtilクラスで定義されるデフォルト値を設定する
	 *
	 * デバッグ情報の更新もあわせて行なう
	 *
	 * @param  none
	 * @return none
	 */
	private void initAp2ServerConf() {																	//DEL@PROD
		Log.i("MyApplication", "initAp2ServerConf");														//DEL@PROD
																										//DEL@PROD
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);					//DEL@PROD
		final int httpPort	= prefs.getInt("ExternalServiceUtil.apServerHttpPort",	ExternalServiceUtil.AP2_HTTP_PORT); //DEL@PROD
		final int httpsPort	= prefs.getInt("ExternalServiceUtil.apServerHttpsPort",	ExternalServiceUtil.AP2_HTTPS_PORT);//DEL@PROD
																										//DEL@PROD
		ExternalServiceUtil.setAp2ServerHttpPort(Integer.valueOf(httpPort));								//DEL@PROD
		ExternalServiceUtil.setAp2ServerHttpsPort(Integer.valueOf(httpsPort));							//DEL@PROD
																										//DEL@PROD
		setAp2ServerDebugInfo(httpPort, httpsPort);														//DEL@PROD
	}																									//DEL@PROD
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12

	/**
	 * APサーバに接続する際のHTTP/HTTPSポートをパラメータの値に設定する<br>
	 *
	 * デバッグ情報の更新もあわせて行なう
	 *
	 * @param httpPort
	 * @param httpsPort
	 */
	private void setApServerConf(final int httpPort, final int httpsPort) {								//DEL@PROD
		Log.i("MyApplication", "setApServerConf(): httpPort=" + httpPort + ", httpsPort=" + httpsPort);	//DEL@PROD
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);					//DEL@PROD
		SharedPreferences.Editor editor = prefs.edit();													//DEL@PROD
																										//DEL@PROD
		ExternalServiceUtil.setApServerHttpPort(httpPort);												//DEL@PROD
		ExternalServiceUtil.setApServerHttpsPort(httpsPort);											//DEL@PROD
		editor.putInt("ExternalServiceUtil.apServerHttpPort",	httpPort);								//DEL@PROD
		editor.putInt("ExternalServiceUtil.apServerHttpsPort",	httpsPort);								//DEL@PROD
		editor.commit();																				//DEL@PROD
																										//DEL@PROD
		setApServerDebugInfo(httpPort, httpsPort);														//DEL@PROD
	}																									//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
	/**
	 * AP2サーバに接続する際のHTTP/HTTPSポートをパラメータの値に設定する<br>
	 *
	 * デバッグ情報の更新もあわせて行なう
	 *
	 * @param httpPort
	 * @param httpsPort
	 */
	private void setAp2ServerConf(final int httpPort, final int httpsPort) {								//DEL@PROD
		Log.i("MyApplication", "setAp2ServerConf(): httpPort=" + httpPort + ", httpsPort=" + httpsPort);	//DEL@PROD
		SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);					//DEL@PROD
		SharedPreferences.Editor editor = prefs.edit();													//DEL@PROD
																										//DEL@PROD
		ExternalServiceUtil.setAp2ServerHttpPort(httpPort);												//DEL@PROD
		ExternalServiceUtil.setAp2ServerHttpsPort(httpsPort);											//DEL@PROD
		editor.putInt("ExternalServiceUtil.apServerHttpPort",	httpPort);								//DEL@PROD
		editor.putInt("ExternalServiceUtil.apServerHttpsPort",	httpsPort);								//DEL@PROD
		editor.commit();																				//DEL@PROD
																										//DEL@PROD
		setAp2ServerDebugInfo(httpPort, httpsPort);														//DEL@PROD
	}																									//DEL@PROD
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
	/**
	 * デバッグ用表示情報(接続先APサーバ情報)を設定する
	 *
	 * @param httpPort
	 * @param httpsPort
	 */
	private void setApServerDebugInfo(final int httpPort, final int httpsPort) {						//DEL@PROD
		final String category = "接続先APサーバ情報";													//DEL@PROD
		DebugInfo debugInfo = DebugInfo.getInstance();													//DEL@PROD
		debugInfo.setDebugInfo(category, "ホスト", ExternalServiceUtil.getApServerHost());				//DEL@PROD
		debugInfo.setDebugInfo(category, "ポート番号(http)", String.valueOf(httpPort));					//DEL@PROD
		debugInfo.setDebugInfo(category, "ポート番号(https)", String.valueOf(httpsPort));				//DEL@PROD
	}																									//DEL@PROD
// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12
	/**
	 * デバッグ用表示情報(接続先AP2サーバ情報)を設定する
	 *
	 * @param httpPort
	 * @param httpsPort
	 */
	private void setAp2ServerDebugInfo(final int httpPort, final int httpsPort) {						//DEL@PROD
		final String category = "接続先AP2サーバ情報";													//DEL@PROD
		DebugInfo debugInfo = DebugInfo.getInstance();													//DEL@PROD
		debugInfo.setDebugInfo(category, "ホスト", ExternalServiceUtil.getAp2ServerHost());				//DEL@PROD
		debugInfo.setDebugInfo(category, "ポート番号(http)", String.valueOf(httpPort));					//DEL@PROD
		debugInfo.setDebugInfo(category, "ポート番号(https)", String.valueOf(httpsPort));				//DEL@PROD
	}	                                                                                                //DEL@PROD
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
// ADD-ST #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
	/**
	 * デバッグ用表示情報(位置情報)を設定する
	 *
	 * @param httpPort
	 * @param httpsPort
	 */
	public void positionDebugInfo() {
		String localStorageRegionObserve = getPreference("RegionObserve");
		if("undefined".equals(localStorageRegionObserve)) {
			localStorageRegionObserve = "{}";
		}
		int RegionObserveState = -1;
		String RegionObserveTime = "";
		String position = "-";
		String geofenceTransition = "-";
		try {
			JSONObject RegionObserveStorage = new JSONObject(localStorageRegionObserve);
			RegionObserveState = RegionObserveStorage.getInt("RegionObserveState");
			RegionObserveTime = RegionObserveStorage.getString("RegionObserveTime");
			position = RegionObserveStorage.getString("positionInfo");
			if (RegionObserveState == Geofence.GEOFENCE_TRANSITION_ENTER) {
				geofenceTransition = "ENTER";
			} else if (RegionObserveState == Geofence.GEOFENCE_TRANSITION_EXIT) {
				geofenceTransition = "EXIT";
			}
			geofenceTransition += " " +RegionObserveTime;
		} catch (Exception e) {
			e.printStackTrace();
		}

		AlertDialog.Builder infoDialog = new AlertDialog.Builder(StartApp.this);
		infoDialog.setTitle("位置情報");
		String info = "・" + "現在の位置情報" + " : " + position + "　" + "\n" + 
				"・" + "ジオフェンス情報" + " : " + geofenceTransition + "　" + "\n";
		TextView tView = new TextView(StartApp.this);
		tView.setTextColor(Color.WHITE);
		tView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14f);
		tView.setText(info);
		ScrollView sView = new ScrollView(StartApp.this);
		sView.addView(tView);
		infoDialog.setView(sView).show();
	}
// ADD-ED #25394:【PUSH通知】位置情報取得に関するログ PSDCD徐　2016-02-16
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD肖　2014-12-12																									//DEL@PROD
// ADD-END  TF-#10133 STG#2 立ち上げ対応(Androidアプリの対応) PMCRD門畑 2013-06-17

//ADD-ST PAD-#11726
	/**
	 * ページ読み込み状態取得<br>
	 * @param  none
	 * @return ページ読み込み状態
	 */
	public boolean getPageLoadingStatus() {
		Log.i("MyApplication", "getPageLoadingStatus() isPageLoading=" + isPageLoading);

		return isPageLoading;
	}

	/**
	 * バージョン情報取得における通信エラーからの復帰<br>
	 * @param  none
	 * @return none
	 */
	public void retryVersionInfo() {
		Log.i("MyApplication", "retryVersionInfo() isAppStartUp=" + isAppStartUp);

		// アプリ起動時、バージョン情報が未取得の場合は再取得を行う
		if (isAppStartUp) {
			boolean isError = VersionCheck.getInstance().getVersionInfoResult();
			Log.i("MyApplication", "retryVersionInfo() isError=" + isError);
			if (isError) {
				VersionCheck.getInstance().doGetByHttpClient(VERSION_FILE);
			}
		}
	}
//ADD-EN PAD-#11726

//ADD-ST #22950【PRIDE再構築】 システム側から指定されたファイル名での保存処理対応
    /**
     * 【使い方ガイド】Content-Dispositionでファイル名を取得する<br>
     * @param url		元ダウンロードURL
     */
    public String getRealFileName(String url) {
		Log.i("MyApplication", "getRealFileName() url=" + url);

        String filename = "";
        URL myURL;
        HttpURLConnection conn = null;
        if (url == null || url.length() < 1) {
            return null;
        }

        try {
            myURL = new URL(url);
            conn = (HttpURLConnection) myURL.openConnection();
            conn.connect();
            // conn.getResponseCode();
            // 真実Urlを取得する
            URL absUrl = conn.getURL();
            Log.i("MyApplication", "absUrl:" + absUrl);
            // Header情報をログで表示する
			Map<String, List<String>> map = conn.getHeaderFields();
			for (String str : map.keySet()) {
				if (str != null) {
					Log.i("MyApplication", str + map.get(str));
				}
			}
			// Content-Dispositionでファイル名を取得する
            filename = conn.getHeaderField("Content-Disposition");
            if (filename != "" && filename != null) {
                filename = filename.split(";")[1].replaceAll(" filename=", "");
                filename = filename.substring(1, filename.length() - 1);
            } else {
            	 String urlStr = absUrl.getFile();
			     // URLからファイル名を抽出し
			     int index = urlStr.lastIndexOf('/');
            	 filename = urlStr.substring(index + 1);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (conn != null) {
                conn.disconnect();
                conn = null;
            }
        }

        return filename;
    }

    /**
     * 【使い方ガイド】取説ダウンロードURLのファイル名を転換する(ファイル名「1428052116794.pdf」→「ne_bs1100.pdf」)<br>
     * （JS→Main）<br>
     * @param url		元ダウンロードURL
     */
    public void translateToRealFileName(final String url) {
    	Log.i("MyApplication", "translateToRealFileName() url=" + url);

    	Runnable mConnect = new Runnable() {
    		@Override
    		public void run() {
    			String realFileName = getRealFileName(url);
    			String realUrl = url.substring(0, url.lastIndexOf("/") + 1) + realFileName;
    	        Log.i("MyApplication", "realUrl=" + realUrl);
				// ファイル名を転換完了の通知
    	        jsB.notifyDownloadByRealFileName(realUrl);
    		}
    	};
    	Thread mThread = new Thread(mConnect);
        mThread.start();
	}
//ADD-ED #22950【PRIDE再構築】 システム側から指定されたファイル名での保存処理対応

// ADD-ST 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
	/**
	 *  電話をする
	 */
// CHG-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	public void callPhone(String phone_num) {
		Log.d("MyApplication", "callPhone() phone_num=" + phone_num);		
		
		Toast.makeText(getApplicationContext(), "発信操作を行ってください", Toast.LENGTH_LONG).show();
		
		if( phone_num == null || phone_num == "" ){
			Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phone_num));  
			startActivity(intent);
		} else {
			Intent dialIntent = new Intent(Intent.ACTION_CALL, Uri.parse("tel:" + phone_num));  
			startActivity(dialIntent);  
		}
	}
// CHG-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	
// ADD-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	/**
	 *  電話帳を呼び出す
	 */
	public void callTelBook() {
		Log.d("MyApplication", "callTelBook()");
		
		Toast.makeText(getApplicationContext(), "発信操作を行ってください", Toast.LENGTH_LONG).show();

// MOD-ST 作業管理 #24983: 【PUSH通知ST：室温みはり】電話をかける操作について
		// 電話帳の連絡先選択、電話番号手入力方式での呼び出しを実現するために、電話アプリを起動する
		//Intent intent = new Intent(Intent.ACTION_PICK,ContactsContract.Contacts.CONTENT_URI);
		//startActivityForResult(intent, REQUEST_CONTACTS);
		Intent intent = new Intent(Intent.ACTION_DIAL, null);
		startActivity(intent);
// MOD-ED 作業管理 #24983: 【PUSH通知ST：室温みはり】電話をかける操作について
	}
// ADD-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ
	
	/**
	 * ローカルでプッシュＰＵ画面を表示する。
	 * @param serviceID PUSH通知サービス種別 
	 * @param applianceID 機器ID
	 * @param alertMsg ポップアップ表示用メッセージ
	 */
	public void loadPushPopUrl(String serviceID, String applianceID, String alertMsg) {
		Log.d("MyApplication", "loadPushPopUrl() serviceID=" + serviceID + "applianceID=" + applianceID + "alertMsg=" + alertMsg);

		// メッセージポップアップの文字がすごく小さくなる対応
		String loginUrl = GEMINI_PUSH_URL + "PUSH_FLAG&appliance_id=" + jsB.URLEncoderEncode(applianceID)  + "&service_id=" + serviceID + "&alert_msg=" + jsB.URLEncoderEncode(alertMsg);
		
		Log.d("MyApplication", "onCreate() loadUrl:" + loginUrl);
		wv.loadUrl(loginUrl);
	}

// ADD-ST #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
// CHG-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
	public void showNotification(String serviceID, String applianceID, String msg, String titletext) {
// CHG-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
		Log.d("MyApplication", "showNotification() serviceID=" + serviceID + ",applianceID=" + applianceID + ",msg" + msg + ",titletext" + titletext);

		// 通知欄メッセージのタイトル
// CHG-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
		String title = "通知";
		if((titletext != null)&&(titletext != "")) {
			title = titletext;
		}
// CHG-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
		// 通知は最初表示時の内容
// CHG-ST 作業管理 #24427: 【PUSH通知残課題対応】画面上部に「タイトル」を表示。PT中／iOSはトースト表示 PSDCD徐 2015-11-25
		String firstNotifyStatusBarText = title;
// CHG-ED 作業管理 #24427: 【PUSH通知残課題対応】画面上部に「タイトル」を表示。PT中／iOSはトースト表示 PSDCD徐 2015-11-25
		// アプリ名
		String appName = getResources().getString(R.string.app_name);
		// 通知のＩＤを作成する「日＋時＋分＋秒」
		Date currentDate = new Date();
// CHG-ST 作業管理 #24427: 【PUSH通知残課題対応】画面上部に「タイトル」を表示。PT中／iOSはトースト表示 PSDCD徐 2015-11-25
		String notifyId = String.valueOf((int)(currentDate.getTime() % 1000000));
// CHG-ED 作業管理 #24427: 【PUSH通知残課題対応】画面上部に「タイトル」を表示。PT中／iOSはトースト表示 PSDCD徐 2015-11-25
		Log.d("MyApplication", "notifyId=" + notifyId);
		
		Intent newIntent = new Intent(getApplicationContext(), StartApp.class);
		newIntent.setAction(ACTION_PUSH_MESSAGE_GCM);
		// PUSH通知サービス種別
		newIntent.putExtra(PUSH_RECEIVE_APPLIANCE_ID, applianceID);
		// 機器ＩＤ
		newIntent.putExtra(PUSH_RECEIVE_MESSAGE, msg);
		// ポップアップ表示用メッセージ
		newIntent.putExtra(PUSH_RECEIVE_SERVICE_ID, serviceID);
		
		newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		newIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
		newIntent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
		newIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
		newIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
		
		PendingIntent pendingIntent = PendingIntent.getActivity(getApplicationContext(), Integer.parseInt(notifyId), newIntent, PendingIntent.FLAG_UPDATE_CURRENT);
// DEL-ST #24839:【PUSH通知残課題対応】GooglePlayサービスデータ消去時に自宅監視を再開する必要がある PSDCD徐 2016-01-15   //DEL@PROD
// DEL-ED #24839:【PUSH通知残課題対応】GooglePlayサービスデータ消去時に自宅監視を再開する必要がある PSDCD徐 2016-01-15   //DEL@PROD
// CHG-ST #24479:【PUSH通知残課題対応】Android6.0対応 PSDCD徐 2015-12-25
// CHG-ST 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
		Notification notification = null;
		if (android.os.Build.VERSION.SDK_INT < 23){
			notification = new Notification(R.drawable.notification_icon, firstNotifyStatusBarText, System.currentTimeMillis());
			notification.setLatestEventInfo(getApplicationContext(), appName, title, pendingIntent);
		} else {
			notification = new Notification.Builder(this.getApplicationContext())
	         .setContentTitle(firstNotifyStatusBarText)
	         .setContentIntent(pendingIntent)
	         .setTicker(firstNotifyStatusBarText)
	         .setSmallIcon(R.drawable.notification_icon)
	         .build();
		}
// CHG-ED 作業管理 #21007: 【PUSH通知】2月デモ向け実装：携帯アプリ PSDCD李氷
// CHG-ST #24479:【PUSH通知残課題対応】Android6.0対応 PSDCD徐 2015-12-25
	    notification.defaults = Notification.DEFAULT_SOUND;                        
	    notification.flags = Notification.FLAG_AUTO_CANCEL;  
		
	    NotificationManager notificationManager = (NotificationManager) getApplicationContext().getSystemService(
	                    android.content.Context.NOTIFICATION_SERVICE);
	    notificationManager.notify(Integer.parseInt(notifyId), notification);
	}
// ADD-ED #20835:【PUSH通知】結合Step1(12月)実装：携帯アプリ PSDCD李
// ADD-ED 作業管理 #20835: 【PUSH通知】結合Step1(12月)実装：携帯アプリ　PSDCD李
// ADD-ST 作業管理 #23164:【PUSH通知＠海外連携】エアコン消し忘れ防止実装 PSDCD李
    /**
	 * （JS→Main）<br>
	 *  GCMを登録
	 */
	public void registerForRemoteNotifications() {
		Log.i("MyApplication", "registerForRemoteNotifications");
		try {
	        // システムバージョン・Ｇｏｏｇｌｅサービスがあるかどうかチェック
	        GCMRegistrar.checkDevice(getApplicationContext());
		} catch (Exception e) {
			Toast.makeText(getApplicationContext(), "device isn't support google service", Toast.LENGTH_LONG).show();
			jsB.registerForRemoteNotificationsResult(false);
		}
		final String regId = GCMRegistrar.getRegistrationId(getApplicationContext());
        Log.i("MyApplication", "regId:" + regId);
        if (regId.equals("")) {
        	// GCMを登録して、「com.google.android.c2dm.intent.REGISTER」を起動する
// CHG-ST #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
        	Log.d("MyApplication", "senderId= " + senderId); 
        	GCMRegistrar.register(getApplicationContext(), senderId); 
// CHG-ED #26024:GCM送信用プロジェクト番号の反映 PSDCD肖 2016-03-18
        	Log.i("MyApplication", "New Device:"+GCMRegistrar.isRegistered(getApplicationContext())); 
        } else {
        	Log.i("MyApplication", "Already Registered"); 
        	jsB.registerForRemoteNotificationsResult(true);
        }
	}
	
    /**
	 * （JS→Main）
	 *  端末の通知設定ON・OFF状態を取得する
	 */
	public boolean isPushEnable () {
		Log.i("MyApplication", "isPushEnable()");
// CHG-ST 作業管理 #24426:【PUSH通知残課題対応】Android4.1以降「設定＞アプリ」での通知ON/OFF設定状態を取得できない PSDCD徐 2015-12-02
		if (android.os.Build.VERSION.SDK_INT < 19){
			//(Android 4.4 （Level 19)
			return true;    	  
		} else {
			return isNotificationEnabled(this);
		}
	}

    public static boolean isNotificationEnabled(Context context) {
    	
    	AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);
    	ApplicationInfo appInfo = context.getApplicationInfo();
    	String pkg = context.getApplicationContext().getPackageName();
    	int uid = appInfo.uid;
    	Class appOpsClass = null;
    	try {
    		appOpsClass = Class.forName(AppOpsManager.class.getName());
    		Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class);
    		Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION);
    		int value = (Integer)opPostNotificationValue.get(Integer.class);
    		return ((Integer)checkOpNoThrowMethod.invoke(mAppOps,value, uid, pkg) == AppOpsManager.MODE_ALLOWED);
    	} catch (ClassNotFoundException e) {
    		e.printStackTrace();
    	} catch (NoSuchMethodException e) {
    		e.printStackTrace();
    	} catch (NoSuchFieldException e) {
    		e.printStackTrace();
    	} catch (InvocationTargetException e) {
    		e.printStackTrace();
    	} catch (IllegalAccessException e) {
    		e.printStackTrace();
    	}
    	return false;
	}
// CHG-ED 作業管理 #24426:【PUSH通知残課題対応】Android4.1以降「設定＞アプリ」での通知ON/OFF設定状態を取得できない PSDCD徐 2015-12-02

    /**
	 * （JS→Main）
	 *  端末のGPS設定ON・OFF状態を取得する
	 */
	public boolean isGPSEnable () {
		Log.i("MyApplication", "isGPSEnable()");

		LocationManager lm = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
	    boolean status = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
	    return status;
	};
// ADD-ST #24839:【PUSH通知残課題対応】GooglePlayサービスデータ消去時に自宅監視を再開する必要がある PSDCD徐 2016-01-19
	/**
	 * アプリIDを取得する。<br>
	 * @return アプリID（16進数の文字列）
	 */
    public static String getAppAuthId() {
    	String ver = "0001";       //バージョン（2バイト）
    	String company = "000000000001";   //企業コード（6バイト）
    	//String serial  = "0000000000000001";   //シリアル番号（8バイト）:2012/6月版
    	String serial  = "0000000000000002";   //シリアル番号（8バイト）:2012/9月版
    	return ver + company + serial;
    }

	/**
	 * パスコードを取得する。<br>
	 * @return パスコード（16進数の文字列）
	 */
    public static String getAppAuthPassCode() {
    	//return "47F93458AF39E52ABF389985092CEE3C";      //2012/6月版
    	return "93049D4EC87EB83CEF8A82EF575C45D7";      //2012/9月版
    }
// ADD-ED #24839:【PUSH通知残課題対応】GooglePlayサービスデータ消去時に自宅監視を再開する必要がある PSDCD徐 2016-01-19
// ADD-ST #24421:【PUSH通知残課題対応】閾値判定処理が正しく動作しない PSDCD肖 2015-11-27
    /**
	 * （Main→JS）
	 *  切り忘れ防止を通知する
	 */
	public void notifyDidExitRegion(final String jsonString) {
		Log.i("MyApplication", "notifyDidExitRegion() jsonString=" + jsonString);
		mRespHandler.post( new Runnable() {
			public void run() {
				try {
					JSONObject jsonObj = new JSONObject(jsonString);
// CHG-ST 作業管理 #24425: 【PUSH通知残課題対応】アプリ停止状態でのサーバ通知／ローカル通知対応 PSDCD張 2015-12-07
// DEL-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
// DEL-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
// CHG-ST #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
						if (Util.USE_DEBUG_LOG) {
// CHG-ST #24841:【PUSH通知】閾値を超えた場合のローカル通知機能の追加 PSDCD徐 2015-12-22
							Date currentDate = new Date();
							String MonthString = currentDate.getMonth()<9?("0"+String.valueOf(currentDate.getMonth()+1)):String.valueOf(currentDate.getMonth()+1);
							String DateString = currentDate.getDate()<10?("0"+String.valueOf(currentDate.getDate())):String.valueOf(currentDate.getDate());
							String HourString = currentDate.getHours()<10?("0"+String.valueOf(currentDate.getHours())):String.valueOf(currentDate.getHours());
							String MinuteString = currentDate.getMinutes()<10?("0"+String.valueOf(currentDate.getMinutes())):String.valueOf(currentDate.getMinutes());
							String TimeString =  MonthString+ "/" +DateString + " " + HourString + ":" + MinuteString;
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
							boolean byMenu= false;
							if (jsonObj.has("byMenu")) {
								byMenu = jsonObj.getBoolean("byMenu");
							}
							if (!CONVENTION_DEMO_FLAG) {
								showNotification("","","","閾値を超えました！"+TimeString);
							} else if (!byMenu) {
								showNotification("","","","閾値を超えました！"+TimeString);
							}
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17						
// CHG-ED #24841:【PUSH通知】閾値を超えた場合のローカル通知機能の追加 PSDCD徐 2015-12-22
						}
// CHG-ED #25396:【PUSH通知】開発向け機能の有効条件変更 PSDCD徐 2016-02-22
						String serviceId = jsonObj.getString("service_id");
// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない） PSDCD張 2015-12-30
						sendLocalNotifyOnAppFinished(serviceId, StartApp.this.getApplicationContext());
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない） PSDCD張 2015-12-30
// DEL-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
// DEL-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
// CHG-ED 作業管理 #24425: 【PUSH通知残課題対応】アプリ停止状態でのサーバ通知／ローカル通知対応 PSDCD張 2015-12-07
				} catch (JSONException e) {
					e.printStackTrace();
					Log.e("MyApplication", "  failed to create a new JSONObject");
				}
			}
		});
	}
// ADD-ED #24421:【PUSH通知残課題対応】閾値判定処理が正しく動作しない PSDCD肖 2015-11-27
// ADD-ED 作業管理 #23164:【PUSH通知＠海外連携】エアコン消し忘れ防止実装 PSDCD李

// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない） PSDCD張 2015-12-30
// ADD-ST 作業管理 #24425: 【PUSH通知残課題対応】アプリ停止状態でのサーバ通知／ローカル通知対応 PSDCD張 2015-12-07
	private static Map<String, Map<String, String>> mPushRequestMap = new HashMap<String, Map<String, String>>();
// ADD-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
	private static int appRequestId = 0;
// ADD-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
	protected static void sendLocalNotifyOnAppFinished(String serviceId, Context context)
	{
		Log.i("MyApplication", "sendLocalNotifyOnAppFinished() serviceId=" + serviceId);
		String localStorageMessagePush = Util.getPreference("messagePush", context);
		if("undefined".equals(localStorageMessagePush))
		{
			localStorageMessagePush = "{}";
		}
		String localStorageCommon = Util.getPreference("common", context);
		if("undefined".equals(localStorageCommon))
		{
			localStorageCommon = "{}";
		}
		String termId = "";
		JSONObject messagePushStorage = null;
		try {
			messagePushStorage = new JSONObject(localStorageMessagePush);
			termId = messagePushStorage.getString("term_id");
		} catch (JSONException e1) {
			e1.printStackTrace();
			messagePushStorage = new JSONObject();
		}
		
		// settings Webapiを呼び出す
		ExternalServiceUtil.setContext(context);
		int requestId = ExternalServiceUtil.doGetByHttpClient(3, "api/v1/notify/settings", "[{term_id : " + termId + "}]");
// CHG-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
		Log.d("MyApplication", "settings requestid=" + requestId);
		setAppRequestId(requestId);
// CHG-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
		Map<String, String> requestExtraInfo = new HashMap<String, String>();
		requestExtraInfo.put("type", "settingsRespForPush");
		requestExtraInfo.put("data", serviceId);
		mPushRequestMap.put("" + requestId, requestExtraInfo);
	}
	
// ADD-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
	public static void setAppRequestId(int requestId) {
		Log.i("MyApplication", "setAppRequestId(), requestId=" + requestId);
		appRequestId = requestId;
	}

	public static int getAppRequestId() {
		Log.i("MyApplication", "getAppRequestId(), appRequestId=" + appRequestId);
		return appRequestId;
	}
// ADD-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
	private static boolean checkTurnOnOffNotificationNeedShow(String serviceId, String applianceId, JSONObject pushStorage, String loginId, Boolean updateFlag, Context context)
	{
		Log.i("MyApplication", "checkTurnOnOffNotificationNeedShow serviceId="+serviceId+" applianceId="+applianceId);
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
		boolean ret = true;
		long curTime = Calendar.getInstance().getTimeInMillis();
		// 通知の送信時間間隔：60分
		int thresHoldVal = 60;
		String thresHoldStr = Util.getPreference("threshold_key", context);
		if(!"undefined".equals(thresHoldStr))
		{
			thresHoldVal = Integer.parseInt(thresHoldStr);
		}
		try {
			if(pushStorage.has(loginId))
			{
				Log.d("MainApplication", loginId + "のデータが存在");
				JSONObject loginIdTimer = pushStorage.getJSONObject(loginId);
				if(loginIdTimer.has(serviceId))
				{
					Log.d("MainApplication", serviceId + "のデータが存在");
					JSONObject serviceTimer = loginIdTimer.getJSONObject(serviceId);
					if(serviceTimer.has(applianceId))
					{
						Log.d("MainApplication", applianceId + "のデータが存在");
						JSONObject applianceTimer = serviceTimer.getJSONObject(applianceId);
						if(applianceTimer.has("lastMessageTime"))
						{
							long lastNotifyTsp = applianceTimer.getLong("lastMessageTime");
							Log.d("MainApplication", "lastMessageTimeのデータが存在=" + lastNotifyTsp);
							if(curTime - lastNotifyTsp > thresHoldVal*60*1000)
							{
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
								if (updateFlag) {
									Log.d("MainApplication", "通知間隔閾値を越したので、通知を行う curTime=" + curTime);
									applianceTimer.put("lastMessageTime", curTime);									
									Util.setPreference("messagePush", pushStorage.toString(), context);
								}
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
							}
							else
							{
								ret = false;
							}
						}
/* ADD-ST #26036:【PUSH通知：切り忘れ】「切り忘れ通知」設定をOFF⇒ONにしても切り忘れ通知が来ない PSDCD張 2016-03-18 */
						else
						{
							if (updateFlag) {
								applianceTimer.put("lastMessageTime", curTime);									
								Util.setPreference("messagePush", pushStorage.toString(), context);
							}
						}
/* CHG-ED #26036:【PUSH通知：切り忘れ】「切り忘れ通知」設定をOFF⇒ONにしても切り忘れ通知が来ない PSDCD張 2016-03-18 */
					}
					else
					{
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
						if (updateFlag) {
							serviceTimer.put(applianceId, new JSONObject().put("lastMessageTime", curTime));
							Util.setPreference("messagePush", pushStorage.toString(), context);
						}
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
					}
				}
				else
				{
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
					if (updateFlag) {
						loginIdTimer.put(serviceId, new JSONObject().put(applianceId, new JSONObject().put("lastMessageTime", curTime)));
						Util.setPreference("messagePush", pushStorage.toString(), context);
					}
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
				}
			}
			else
			{
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
				if (updateFlag) {
					pushStorage.put(loginId, new JSONObject().put(serviceId, new JSONObject().put(applianceId, new JSONObject().put("lastMessageTime", curTime))));
					Util.setPreference("messagePush", pushStorage.toString(), context);
				}
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
			}
		} catch (JSONException e) {
			e.printStackTrace();
		}
		Log.i("MyApplication", "checkTurnOnOffNotificationNeedShow ret=" + ret);
		return ret;
	}
	
	public static void notifyHttpClientResult(int requestId, int responseCode, Context context)
	{
		Log.i("MyApplication", "notifyHttpClientResult responseCode=" + responseCode);
		if(!mPushRequestMap.containsKey("" + requestId))
		{
			return;
		}
		
		Map<String, String> requestExtraInfo = mPushRequestMap.get("" + requestId); 
		String data = requestExtraInfo.get("data");
		String type = requestExtraInfo.get("type");
		Log.d("MainApplication", "type=" + type);
		Log.d("MainApplication", "data=" + data);
		if("settingsRespForPush".equals(type) && responseCode == 200)
		{
			onSettingsRespForPush(requestId, data, context);
		}
		else if("analysisRespForPush".equals(type) && responseCode == 200)
		{
			onAnalysisRespForPush(requestId, data, context);
// ADD-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
		}
		else if ("settingsRespForCheckState".equals(type) && responseCode == 200)
		{
			checkRegionObservationResult(requestId, context);
// ADD-ED #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
// ADD-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15
		}
		else if ("settingsRespForCheckState".equals(type) && responseCode == -1 && SysBootedReceiver.isSysBooted)
		{
			Log.i("MyApplication", "sleep 1000");
	        try {
	            Thread.sleep(1000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
			checkRegionObservationState(context);
// ADD-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15
		}
	}
	
	private static void onAnalysisRespForPush(int requestId, String serviceId, Context context)
	{
		Log.i("MyApplication", "onAnalysisRespForPush");
		String localStorageMessagePush = Util.getPreference("messagePush", context);
		if("undefined".equals(localStorageMessagePush))
		{
			localStorageMessagePush = "{}";
		}
		String localStorageCommon = Util.getPreference("common", context);
		if("undefined".equals(localStorageCommon))
		{
			localStorageCommon = "{}";
		}

		String loginId = "";
		JSONObject messagePushStorage = null;
		JSONObject commonStorage = null;
		try {
			messagePushStorage = new JSONObject(localStorageMessagePush);
			commonStorage = new JSONObject(localStorageCommon);
			loginId = commonStorage.getString("loginID");
			String response = ExternalServiceUtil.getResponseBodyForHttpClient(requestId);
			if(response != null)
			{
				JSONObject responseObj = new JSONObject(response);
				JSONArray localNotifyTargets = responseObj.getJSONObject("data").getJSONArray("appliances");
				for(int j=0;j<localNotifyTargets.length();j++)
				{
					JSONObject targetItem = localNotifyTargets.getJSONObject(j);
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
					boolean notifyFlag = "true".equals(targetItem.getString("result"));
					if (CONVENTION_DEMO_FLAG) {
						notifyFlag = true;
					}
					Log.d("MyApplication", "notifyFlag=" + notifyFlag);
					if(notifyFlag)
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
					{
						String title = "";
						String message = "";
						if(serviceId.equals("CS_turnoff"))
						{
// ADD-ST 作業管理 #24537:【PUSH通知】文言確定に伴う対応 PSDCD徐 2015-12-15
							String name = targetItem.getString("name");
// ADD-ST #24855:【PUSH通知IT】【携帯アプリ】iOSにてMy家電名称に特殊文字が含まれる場合、ローカルプッシュが表示されない場合がある PSDCD肖 2016-01-11
							name = name.replaceAll("&quot;", "\"").replaceAll("&lt;", "<").replaceAll("&gt;", ">").replaceAll("&apos;", "'").replaceAll("&amp;", "&");
// ADD-ED #24855:【PUSH通知IT】【携帯アプリ】iOSにてMy家電名称に特殊文字が含まれる場合、ローカルプッシュが表示されない場合がある PSDCD肖 2016-01-11
							title = "エアコン切り忘れ通知：" + name;
							message = "が運転中のままです。";
// ADD-ED 作業管理 #24537:【PUSH通知】文言確定に伴う対応 PSDCD徐 2015-12-15
						}
						else if(serviceId.equals("CS_turnon"))
						{
							title = "快適帰宅お知らせ：自宅に近づきました。";
							message = "のエアコンを運転しますか？自宅に近づきましたので。";
						}
						String applianceId = targetItem.getString("appliance_id");
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
						boolean shouldSendLocalNotify = checkTurnOnOffNotificationNeedShow(serviceId, applianceId, messagePushStorage, loginId, true, context);
// ADD-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
						if (CONVENTION_DEMO_FLAG) {
							shouldSendLocalNotify = true;
						}
// ADD-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
						if(shouldSendLocalNotify)
						{
							Util.showNotification(serviceId, applianceId, message, title, context);
						}
					}
				}
			}
		} catch (JSONException e1) {
			e1.printStackTrace();
			messagePushStorage = new JSONObject();
		}
	}
	
	private static void onSettingsRespForPush(int requestId, String serviceId, Context context)
	{
		Log.i("MyApplication", "onSettingsRespForPush");
		String localStorageMessagePush = Util.getPreference("messagePush", context);
		if("undefined".equals(localStorageMessagePush))
		{
			localStorageMessagePush = "{}";
		}
		String localStorageCommon = Util.getPreference("common", context);
		if("undefined".equals(localStorageCommon))
		{
			localStorageCommon = "{}";
		}
		String termId = "";
		JSONObject messagePushStorage = null;
// ADD-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
		String loginId = "";
		JSONObject commonStorage = null;
// ADD-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
		try {
			messagePushStorage = new JSONObject(localStorageMessagePush);
			termId = messagePushStorage.getString("term_id");
// ADD-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
			commonStorage = new JSONObject(localStorageCommon);
			loginId = commonStorage.getString("loginID");
// ADD-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
		} catch (JSONException e1) {
			e1.printStackTrace();
			messagePushStorage = new JSONObject();
		}
		try {
			String response = ExternalServiceUtil.getResponseBodyForHttpClient(requestId);
			JSONObject responseObj = new JSONObject(response);
			JSONArray applianceArr = responseObj.getJSONObject("data").getJSONArray("appliances");
			JSONArray analysisApplianceArr = new JSONArray();
			// analysis Webapiを呼び出す
			JSONObject requestData = new JSONObject(); 
			requestData.put("service_id", serviceId);
			requestData.put("term_id", termId);
			JSONObject param = new JSONObject();
			param.put("data", requestData);
			if(applianceArr != null)
			{
				for(int i=0;i<applianceArr.length();i++)
				{
					JSONObject applianceItem = applianceArr.getJSONObject(i); 
// CHG-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
					if((serviceId.equals(applianceItem.getString("service_id"))) && ((applianceItem.getInt("ntfy_flg") == 1) || CONVENTION_DEMO_FLAG))
// CHG-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
					{
// CHG-ST #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
						boolean shouldSendLocalNotify = checkTurnOnOffNotificationNeedShow(serviceId, applianceItem.getString("appliance_id"), messagePushStorage, loginId, false, context);
// ADD-ST #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
						if (CONVENTION_DEMO_FLAG) {
							shouldSendLocalNotify = true;
						}
// ADD-ED #25881:【PUSH通知】開発メニューのデモ向け対応  PSDCD肖 2016-03-17
						if (shouldSendLocalNotify) {
							JSONObject tempJson = new JSONObject();
							tempJson.put("appliance_id", applianceItem.getString("appliance_id"));
							analysisApplianceArr.put(tempJson);							
						}
// CHG-ED #24742:【PUSH通知IT】前回切り忘れ通知表示後から再送時間を経過していない場合でも、分析APIが実行されている PSDCD徐 2015-12-14
					}
					// 8データごとにWebapiを呼び出す
//CHG-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31					
					if(analysisApplianceArr.length() == 8 || (i == applianceArr.length()-1 && analysisApplianceArr.length() > 0)) 
//CHG-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31					
					{
						requestData.put("appliances", analysisApplianceArr);
						int requestId2 = ExternalServiceUtil.doPostByHttpClient(3, "api/v1/notify/analysis", param.toString());
// ADD-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
						Log.d("MyApplication", "analysis requestid=" + requestId2);
						setAppRequestId(requestId2);
// ADD-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
						Map<String, String> requestExtraInfo = new HashMap<String, String>();
						requestExtraInfo.put("type", "analysisRespForPush");
						requestExtraInfo.put("data", serviceId);
						mPushRequestMap.put("" + requestId2, requestExtraInfo);
// CHG-ST #24776:【PUSH通知UT】Android4.1でアプリ停止状態でのローカル通知が受信できない PSDCD張　2015-12-10
						// 処理済み分のデータをクリアする
						analysisApplianceArr = new JSONArray();
// CHG-ED #24776:【PUSH通知UT】Android4.1でアプリ停止状態でのローカル通知が受信できない PSDCD張　2015-12-10
					}
				}
			}
		} catch (JSONException e) {
			e.printStackTrace();
		}
	}
// ADD-ED 作業管理 #24425: 【PUSH通知残課題対応】アプリ停止状態でのサーバ通知／ローカル通知対応 PSDCD張 2015-12-07
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない） PSDCD張 2015-12-30
	
// ADD-ST #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
    /**
	 *  監視開始
	 */
	public static void startRegionObservation(String jsonString, Context context) {
		Log.i("MyApplication", "startRegionObservation() jsonString=" + jsonString);
		gContext = context;
		JSONObject jsonObj = null;
		try {
			jsonObj = new JSONObject(jsonString);
		} catch (JSONException e) {
			e.printStackTrace();
			Log.e("MyApplication", "  failed to create a new JSONObject");
		}
		JSONObject locationJSONObj = null;
		float radius = 0;
		if (jsonObj != null) {
			try {
				locationJSONObj = jsonObj.getJSONObject("location");
				radius = (float)jsonObj.getDouble("radius");
			} catch (JSONException e) {
				e.printStackTrace();
			}

		}
		double latitude = 0;
		double longitude = 0;

		if (locationJSONObj != null) {
			try {
				latitude = locationJSONObj.getDouble("latitude");
				longitude = locationJSONObj.getDouble("longitude");
			} catch (JSONException e) {
				e.printStackTrace();
			}
			
		}
		Log.i("MyApplication", "latitude=" + latitude);
		Log.i("MyApplication", "longitude=" + longitude);
		Log.i("MyApplication", "radius=" + radius);
// ADD-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15
		if (SysBootedReceiver.isSysBooted == false) {
			String localStorageRegionObserve = Util.getPreference("RegionObserve", gContext);
			if("undefined".equals(localStorageRegionObserve)) {
				localStorageRegionObserve = "{}";
			}
			
			JSONObject RegionObserveStorage = null;
			try {
				RegionObserveStorage = new JSONObject(localStorageRegionObserve);
				RegionObserveStorage.put("RegionObserveState","-1");
				Util.setPreference("RegionObserve",RegionObserveStorage.toString(), context);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
    	SysBootedReceiver.isSysBooted = false;
// ADD-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15
        // Empty list for storing geofences.
        mGeofenceList = new ArrayList<Geofence>();

        // Initially set the PendingIntent used in addGeofences() and removeGeofences() to null.
        mGeofencePendingIntent = null;
        // Get the geofences used. Geofence data is hard coded in this sample.
        populateGeofenceList(latitude, longitude, radius);

        // Kick off the request to build GoogleApiClient.
        buildGoogleApiClient(context);
// DEL-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
// DEL-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
	}
    /**
     * Gets a PendingIntent to send with the request to add or remove Geofences. Location Services
     * issues the Intent inside this PendingIntent whenever a geofence transition occurs for the
     * current list of geofences.
     *
     * @return A PendingIntent for the IntentService that handles geofence transitions.
     */
    private static PendingIntent getGeofencePendingIntent() {
        // Reuse the PendingIntent if we already have it.
        if (mGeofencePendingIntent != null) {
            return mGeofencePendingIntent;
        }
        Intent intent = new Intent(gContext, GeofenceTransitionsIntentService.class);
        // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling
        // addGeofences() and removeGeofences().
// CHG-ST #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
        mGeofencePendingIntent = PendingIntent.getService(gContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);//xq
        return mGeofencePendingIntent;
// CHG-ED #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
    }

    /**
     *　GeofenceList生成
     * 
     * @param latitude 経度
     * @param longitude　緯度
     * @param radius　半径
     */
    private static void populateGeofenceList(double latitude, double longitude, float radius) {
    	    Log.i("MyApplication", "populateGeofenceList,latitude=" + latitude + "longitude=" + longitude + "radius=" + radius);
            mGeofenceList.add(new Geofence.Builder()
                    // Set the request ID of the geofence. This is a string to identify this
                    // geofence.
                    .setRequestId(String.valueOf(latitude))

                    // Set the circular region of this geofence.
                    .setCircularRegion(latitude, longitude , radius)

                    // Set the expiration duration of the geofence. This geofence gets automatically
                    // removed after this period of time.
                    .setExpirationDuration(Geofence.NEVER_EXPIRE)

                    // Set the transition types of interest. Alerts are only generated for these
                    // transition. We track entry and exit transitions in this sample.
                    .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER |
                            Geofence.GEOFENCE_TRANSITION_EXIT)

                    // Create the geofence.
                    .build());
    }
    /**
     * Builds a GoogleApiClient. Uses the {@code #addApi} method to request the LocationServices API.
     */
    protected static synchronized void buildGoogleApiClient(Context context) {
    	
    	Log.i("MyApplication", "buildGoogleApiClient");
// ADD-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
    	synchronized (gContext) {
        	if (mGoogleApiClient != null) {
            	Log.i("MyApplication", "mGoogleApiClient != null");
// ADD-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
            	if (mGoogleApiClient.isConnected()) {
            		Log.i("MyApplication", "mGoogleApiClient.isConnected() == true");
            		addGeofences();
            	}
// ADD-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
// ADD-ST #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
            	else {
            		mGoogleApiClient.connect();
            	}
// ADD-ED #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
                return;
            }
		}
// ADD-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
        mGoogleApiClient = new GoogleApiClient.Builder(context)
        .addConnectionCallbacks(new ConnectionCallbacks() {
	        @Override
	        public void onConnected(Bundle connectionHint) {
		        Log.i("MyApplication", "Connected to GoogleApiClient: " + connectionHint);
		        //Toast.makeText(mContext, "Connected to GoogleApiClient", Toast.LENGTH_SHORT).show();
// CHG-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
		        addGeofences();
// CHG-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
	        }
	        @Override
	        public void onConnectionSuspended(int cause) {
	        	Log.d("MyApplication", "onConnectionSuspended: " + cause);
	        }
        })
        .addOnConnectionFailedListener(new OnConnectionFailedListener() {
        	@Override
        	public void onConnectionFailed(ConnectionResult result) {
                Log.i("MyApplication", "Connection failed: ConnectionResult.getErrorCode() = " + result.getErrorCode());
        	}
        })
        .addApi(LocationServices.API)
        .build();

// ADD-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
    	mGoogleApiClient.connect();
// ADD-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27

    }
// ADD-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
    protected static synchronized void addGeofences() {
    	Log.i("MyApplication", "addGeofences");
    	try {
            LocationServices.GeofencingApi.addGeofences(
                    mGoogleApiClient,
                    // The GeofenceRequest object.
                    getGeofencingRequest(),
                    // A pending intent that that is reused when calling removeGeofences(). This
                    // pending intent is used to generate an intent when a matched geofence
                    // transition is observed.
                    getGeofencePendingIntent()
            ).setResultCallback(new ResultCallback<Status> () {
				@Override
				public void onResult(Status status) {
					Log.i("MyApplication", "LocationServices.GeofencingApi.addGeofences onResult");
					if (status.isSuccess()) {
			            //Toast.makeText(gContext, "addGeofences onResult = isSuccess", Toast.LENGTH_SHORT).show();
// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
			            setRegionObserving(true,gContext);
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
			            GeofenceProvidersChangedBroadcastReceiver.checkRetryFlag = false;
			            GeofenceProvidersChangedBroadcastReceiver.handler.removeCallbacks(GeofenceProvidersChangedBroadcastReceiver.runnable);
			        } else {
			            if (GeofenceProvidersChangedBroadcastReceiver.checkRetryFlag) {
			            	GeofenceProvidersChangedBroadcastReceiver.handler.postDelayed(GeofenceProvidersChangedBroadcastReceiver.runnable, 5000);
			            }
			            Log.e("MyApplication", "status.getStatusCode()=" + status.getStatusCode());
			        }
				}
            	
            }); // Result processed in onResult().
            
        } catch (SecurityException securityException) {
            // Catch exception generated if the app does not use ACCESS_FINE_LOCATION permission.
        	Log.e("MyApplication", "Invalid location permission. " +
                    "You need to use ACCESS_FINE_LOCATION with geofences", securityException);
        }
    }
// ADD-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
    /**
     * Builds and returns a GeofencingRequest. Specifies the list of geofences to be monitored.
     * Also specifies how the geofence notifications are initially triggered.
     */
    private static GeofencingRequest getGeofencingRequest() {
    	Log.i("MyApplication", "getGeofencingRequest");
        GeofencingRequest.Builder builder = new GeofencingRequest.Builder();

        // The INITIAL_TRIGGER_ENTER flag indicates that geofencing service should trigger a
        // GEOFENCE_TRANSITION_ENTER notification when the geofence is added and if the device
        // is already inside that geofence.
// CHG-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15
        builder.setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_EXIT | GeofencingRequest.INITIAL_TRIGGER_ENTER);
// CHG-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-15

        // Add the geofences to be monitored by geofencing service.
        builder.addGeofences(mGeofenceList);

        // Return a GeofencingRequest.
        return builder.build();
    }

    /**
	 *  監視停止
	 */
// CHG-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-01-22
	public static void stopRegionObservation(final String jsonString) {
// CHG-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-01-22
		Log.i("MyApplication", "stopRegionObservation()");
		if (mGoogleApiClient == null) {
			Log.i("MyApplication", "mGoogleApiClient == null");
			//Toast.makeText(mContext, "mGoogleApiClient == null", Toast.LENGTH_SHORT).show();
// ADD-ST #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
			if (gContext != null) {
				setRegionObserving(false,gContext);
				if ((jsonString != null) && (!jsonString.equals("undefined"))) {
					startRegionObservation(jsonString,gContext);
				}
			}
// ADD-ED #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
			return;
		} else if (mGoogleApiClient.isConnected() == false) {
			Log.i("MyApplication", "mGoogleApiClient.isConnected() == false");
            //Toast.makeText(mContext, "GoogleApiClient no yet connected. Try again.", Toast.LENGTH_SHORT).show();
// ADD-ST #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
            setRegionObserving(false,gContext);
			if ((jsonString != null) && (!jsonString.equals("undefined"))) {
				startRegionObservation(jsonString,gContext);
			}
// ADD-ED #25317:【PUSH通知SIT】【機種依存？】切り忘れ通知を受信しない PSDCD徐 2016-02-29
            return;
        }
        try {
            // Remove geofences.
            LocationServices.GeofencingApi.removeGeofences(
                    mGoogleApiClient,
                    // This is the same pending intent that was used in addGeofences().
                    getGeofencePendingIntent()
            ).setResultCallback(new ResultCallback<Status> () {
				@Override
				public void onResult(Status status) {
					Log.i("MyApplication", "LocationServices.GeofencingApi.removeGeofences onResult");
					if (status.isSuccess()) {
			            //Toast.makeText(gContext, "removeGeofences onResult = isSuccess", Toast.LENGTH_SHORT).show();
						Log.i("MyApplication", "onResult = isSuccess");
// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
						setRegionObserving(false,gContext);
// ADD-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-01-22
						if ((jsonString != null) && (!jsonString.equals("undefined"))) {
							startRegionObservation(jsonString,gContext);
						}
// ADD-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-01-22
// DEL-ST #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
// DEL-ED #24951:【PUSH通知残課題対応】Google位置情報サービスの設定変更を検出する方法の調査＆対応方法検討 PSDCD徐 2016-01-27
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
			        } else {
			            Log.e("MyApplication", "status.getStatusCode()=" + status.getStatusCode());
			        }
				}
            	
            }); // Result processed in onResult().

        } catch (SecurityException securityException) {
            // Catch exception generated if the app does not use ACCESS_FINE_LOCATION permission.
        	 Log.e("MyApplication", "Invalid location permission. " +
                     "You need to use ACCESS_FINE_LOCATION with geofences", securityException);
        }
	}

// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
    /**
	 *  監視状態を取得する
     * @param context 
	 */
	public static boolean isRegionObserving (Context context) {
		Log.i("MyApplication", "isRegionObserving()");
		//return SysBootedReceiver.isRegionObservingFlg();
		String localStorageRegionObserve = Util.getPreference("RegionObserve", context);
		if("undefined".equals(localStorageRegionObserve)) {
			localStorageRegionObserve = "{}";
		}

		boolean isRegionObservingFlg = false;
		try {
			JSONObject RegionObserveStorage = new JSONObject(localStorageRegionObserve);
			isRegionObservingFlg = RegionObserveStorage.getBoolean("isRegionObserving");
			if(((StartApp)context).isTaskRoot() && (mGoogleApiClient == null)) {
				isRegionObservingFlg = false;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		Log.i("MyApplication", "isRegionObserving = "+isRegionObservingFlg);
		return isRegionObservingFlg;
	}
    /**
	 *  監視状態を設定する
     * @param context 
	 */
	public static void setRegionObserving (boolean flag, Context context) {
		Log.i("MyApplication", "setRegionObserving(), flag=" + flag);
		//isRegionObservingFlg = flag;
        //SysBootedReceiver.setRegionObserving(flag);
		String localStorageRegionObserve = Util.getPreference("RegionObserve", context);
		if("undefined".equals(localStorageRegionObserve)) {
			localStorageRegionObserve = "{}";
		}
		try {
			JSONObject RegionObserveStorage = new JSONObject(localStorageRegionObserve);
			RegionObserveStorage.put("isRegionObserving",flag);
			Util.setPreference("RegionObserve",RegionObserveStorage.toString(), context);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
	
    /**
	 *  監視開始の判定する
	 */
// CHG-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-02
	public static boolean checkRegionObservationState (Context context) {
		Log.i("MyApplication", "checkRegionObservationState()");

		String localStorageMessagePush = Util.getPreference("messagePush", context);
		if("undefined".equals(localStorageMessagePush)) {
			localStorageMessagePush = "{}";
		}
		String termId = "";
		String isMyHouseSetted = "";
		String isLoggedIn = "";
		try {
			JSONObject messagePushStorage = new JSONObject(localStorageMessagePush);
			isMyHouseSetted = messagePushStorage.getString("isMyHouseSetted");
			termId = messagePushStorage.getString("term_id");
			isLoggedIn = messagePushStorage.getString("isLoggedIn");
		} catch (Exception e) {
			e.printStackTrace();
		}
		if (!isMyHouseSetted.equals("true") || !isLoggedIn.equals("true")) {
			Log.d("MyApplication", "isMyHouseSetted=" + isMyHouseSetted+ " isLoggedIn=" + isLoggedIn);
			return false;
		}
// CHG-ST #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
		Boolean isRegionObserving = isRegionObserving(context);
// CHG-ED #24837:【PUSH通知IT】アプリ終了時に自宅範囲を超えても分析APIが実行されない（アラートも表示されない）Android対応 PSDCD徐 2016-01-13
		if (isRegionObserving) {
			return false;
		}
		Boolean isPushEnable = true;
		if (android.os.Build.VERSION.SDK_INT > 19){
			//(Android 4.4 （Level 19)
			isPushEnable = isNotificationEnabled(context);
		}
		if (!isPushEnable) {
			Log.d("MyApplication", "isPushEnable=" + isPushEnable);
			return false;
		}

    	LocationManager lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
	    boolean isGPSEnable = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
        if (!isGPSEnable) {
			Log.d("MyApplication", "isGPSEnable=" + isGPSEnable);
            return false;
        }
	    
        try {
			// settings Webapiを呼び出す
			ExternalServiceUtil.setContext(context);
			int requestId = ExternalServiceUtil.doGetByHttpClient(3, "api/v1/notify/settings", "[{term_id : " + termId + "}]");
			Log.d("MyApplication", "requestid=" + requestId);
// ADD-ST #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
			setAppRequestId(requestId);
// ADD-ED #25679:【PUSH通知:切り忘れ】サーバーと通信不能状態で圏外に移動すると、その後通知を受信できなくなる。 PSDCD徐 2016-02-18
			Map<String, String> requestExtraInfo = new HashMap<String, String>();
			requestExtraInfo.put("type", "settingsRespForCheckState");
			requestExtraInfo.put("data", "");
			mPushRequestMap.put("" + requestId, requestExtraInfo);
		} catch (Exception e) {
			e.printStackTrace();        	
        }
        return true;
	}
// CHG-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-02
	
    /**
	 *  監視開始の判定コールバック
	 */
	public static void checkRegionObservationResult (int requestId, Context context) {
		Log.i("MyApplication", "checkRegionObservationResult() ");
		
		boolean findNtfyFlgOn = false;
		try {
			String response = ExternalServiceUtil.getResponseBodyForHttpClient(requestId);
			JSONObject responseObj = new JSONObject(response);
			JSONArray applianceArr = responseObj.getJSONObject("data").getJSONArray("appliances");
			for (int i=0;i<applianceArr.length();i++) {
				JSONObject applianceItem = applianceArr.getJSONObject(i); 
				if("CS_turnoff".equals(applianceItem.getString("service_id")) && applianceItem.getInt("ntfy_flg") == 1)
				{
					findNtfyFlgOn = true;
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		Log.d("MyApplication", "findNtfyFlgOn=" + findNtfyFlgOn);
		if (!findNtfyFlgOn) {
// ADD-ST #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-102
	    	SysBootedReceiver.isSysBooted = false;
// ADD-ED #25146:【PUSH通知ST：切り忘れ通知】端末電源OFF状態で自宅を離れると、電源ONしても切り忘れ通知がされない PSDCD徐 2016-02-02
			return;
		}
		
		String localStorageMessagePush = Util.getPreference("messagePush", context);
		if("undefined".equals(localStorageMessagePush)) {
			localStorageMessagePush = "{}";
		}
		String radius = "";
		JSONObject location = null;
		try {
			JSONObject messagePushStorage = new JSONObject(localStorageMessagePush);
			radius = messagePushStorage.getString("distance");
			location = messagePushStorage.getJSONObject("myHouseLocation");
// ADD-ST #27093:【PUSH通知】自宅位置暗号化処理の追加 PSDCD肖 2016-07-26
            String secretLatitude = location.getString("latitude");
            String unsecretLatitude = Util.decode(secretLatitude);
            String secretLongitude = location.getString("longitude");
            String unsecretLongitude = Util.decode(secretLongitude);
            JSONObject unsecretLocation = new JSONObject();
            unsecretLocation.put("latitude",unsecretLatitude);
            unsecretLocation.put("longitude",unsecretLongitude);
// ADD-ED #27093:【PUSH通知】自宅位置暗号化処理の追加 PSDCD肖 2016-07-26
			JSONObject locationInfo = new JSONObject();
// CHG-ST #27093:【PUSH通知】自宅位置暗号化処理の追加 PSDCD肖 2016-07-26
			locationInfo.put("location", unsecretLocation);
// CHG-ED #27093:【PUSH通知】自宅位置暗号化処理の追加 PSDCD肖 2016-07-26
			locationInfo.put("radius", radius);
			startRegionObservation(locationInfo.toString(),context);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
// ADD-ED #24898:【PUSH通知残課題対応】GEOFENCE_NOT_AVAILABLE発生時に自宅監視を再開する必要がある  PSDCD徐 2015-12-31
	
}
